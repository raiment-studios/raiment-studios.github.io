<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Raiment Studios Blog</title>
        <link>https://raiment-studios.com/blog</link>
        <description>Raiment Studios Blog</description>
        <lastBuildDate>Mon, 12 Aug 2024 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[WGPU progress]]></title>
            <link>https://raiment-studios.com/blog/2024/08/12/index</link>
            <guid>https://raiment-studios.com/blog/2024/08/12/index</guid>
            <pubDate>Mon, 12 Aug 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Progress update: have some vertices making it from disk to the screen. That's a cube sitting behind of a "2D" pentagon (not necessarily obvious without lights or shading yet).]]></description>
            <content:encoded><![CDATA[<p>Progress update: have some vertices making it from disk to the screen. That's a cube sitting behind of a "2D" pentagon (not necessarily obvious without lights or shading yet).</p>
<p>The general task I've been working on is taking the "catch-all" <code>State</code> object from the <a href="https://sotrh.github.io/learn-wgpu/" target="_blank" rel="noopener noreferrer">Learn Wgpu tutorial</a> and refactoring into a rendering architecture. This requires wrangling with lifetimes and data sharing, both in my learning how Rust works as well as how objects work in wgpu.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-1-1eb40d212c07243966a0d680e442c690.png" width="912" height="740" class="img_ev3q"></p>
<p>A bit more progress, getting basic semi-harcoded face shading working.  Also changed the camera axes to a <code>Z+ =&gt; UP</code> system.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-b9d6eb27ed14cb48d2bcdebedcca0991.png" width="912" height="740" class="img_ev3q"></p>
<p>A bit more progress: depth buffering finally enabled and rendering multiple objects.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-2-71bd199888c8e864ae0473b26023046d.png" width="912" height="740" class="img_ev3q"></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Worth reading]]></title>
            <link>https://raiment-studios.com/blog/2024/08/11/index</link>
            <guid>https://raiment-studios.com/blog/2024/08/11/index</guid>
            <pubDate>Sun, 11 Aug 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[-   Arc and Mutex in Rust - useful examples and explanation about thes Rust types]]></description>
            <content:encoded><![CDATA[<ul>
<li><a href="https://itsallaboutthebit.com/arc-mutex/" target="_blank" rel="noopener noreferrer">Arc and Mutex in Rust</a> - useful examples and explanation about thes Rust types</li>
<li><a href="https://www.reddit.com/r/rust/comments/141ll5b/wgpu_questions_vertex_buffers/" target="_blank" rel="noopener noreferrer">Reddit thread about wgpu buffers</a></li>
<li><a href="https://toji.dev/webgpu-best-practices/buffer-uploads.html" target="_blank" rel="noopener noreferrer">WebGPU Buffer Uploads</a></li>
</ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Following the wgpu tutorial]]></title>
            <link>https://raiment-studios.com/blog/2024/08/10/index</link>
            <guid>https://raiment-studios.com/blog/2024/08/10/index</guid>
            <pubDate>Sat, 10 Aug 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Ramping up on the custom rendering engine by going through the excellent Learn Wgpu tutorial.  There's not much to say that's insightful here, but I find it's nice to create "early days" blog posts and images to highlight progress over time.]]></description>
            <content:encoded><![CDATA[<p>Ramping up on the custom rendering engine by going through the excellent <a href="https://sotrh.github.io/learn-wgpu/" target="_blank" rel="noopener noreferrer">Learn Wgpu tutorial</a>.  There's not much to say that's insightful here, but I find it's nice to create "early days" blog posts and images to highlight progress over time.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-1-c45aff77a0858fed6b3fb55a28575f0e.png" width="912" height="740" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="i-read-a-comment-along-the-lines-of-wgpu-has-so-much-boilerplate">I read a comment along the lines of "wgpu has so much boilerplate"<a href="https://raiment-studios.com/blog/2024/08/10/index#i-read-a-comment-along-the-lines-of-wgpu-has-so-much-boilerplate" class="hash-link" aria-label="Direct link to I read a comment along the lines of &quot;wgpu has so much boilerplate&quot;" title="Direct link to I read a comment along the lines of &quot;wgpu has so much boilerplate&quot;">â€‹</a></h4>
<p>Though pedantic, I'd argue wgpu has a lot of <em>configuration</em>. I tend to consider boilerplate code common text that <em>must be</em> repeated to properly structure or specify another piece of <em>non-common</em> configuration or otherwise unique code. (Note: my personal definition is <em>very</em> different from <a href="https://aws.amazon.com/what-is/boilerplate-code/" target="_blank" rel="noopener noreferrer">AWS' definition</a> which portrays "boilerplate" as a positive).  By "must be repeated", I'm alluding to the kind of code that cannot be encapsulated easily into a reusable function, library, or other standard language primitive -- let's ignore macros certainly blur that line and just run with this hand-wavy definition!</p>
<p>In the context of creating <em>many different wgpu programs</em>, I can see how repeating the exact same configuration would constitue a good deal of "boilerplate code." However, that commonality could be easily wrapped into a reusable library, which -- if we're willing to run with my definition of boilerplate code! -- means it is not boilerplate code as the code does not have the quality that it "must be" repeated.</p>
<p>In the context of a single program, wgpu strikes me simply as a very low-level library with detailed, highly structured configuration.</p>]]></content:encoded>
        </item>
    </channel>
</rss>