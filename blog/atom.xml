<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://raiment-studios.com/blog</id>
    <title>Raiment Studios Blog</title>
    <updated>2024-08-16T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://raiment-studios.com/blog"/>
    <subtitle>Raiment Studios Blog</subtitle>
    <icon>https://raiment-studios.com/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Incremental progress]]></title>
        <id>https://raiment-studios.com/blog/2024/08/16/index</id>
        <link href="https://raiment-studios.com/blog/2024/08/16/index"/>
        <updated>2024-08-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Not much visually different, but improved the code base a bit. Most notably having the engine automtically run model generation scripts (rather than manually running scripts to create static assets) and improved logging.]]></summary>
        <content type="html"><![CDATA[<p>Not much visually different, but improved the code base a bit. Most notably having the engine automtically run model generation scripts (rather than manually running scripts to create static assets) and improved logging.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="changes">Changes<a href="https://raiment-studios.com/blog/2024/08/16/index#changes" class="hash-link" aria-label="Direct link to Changes" title="Direct link to Changes">‚Äã</a></h3>
<p>‚ûï Split model definition YAML from generator script JS<br>
‚ûï Landscape generator takes grid size as an optional parameter<br>
‚ûï Improved logging output<br>
‚ûï Default camera now set based on scene bounds<br>
‚ûï Added <code>id</code> and <code>generation</code> to models to detect cache staleness<br>
‚ûï Added <code>BoundingBox</code><br>
üóÑÔ∏è Split files for better organization<br>
‚ûï git status alias not provides links to diffs on GitHub so summary changelogs like this are easier to create<br></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="potential-next-steps">Potential next steps<a href="https://raiment-studios.com/blog/2024/08/16/index#potential-next-steps" class="hash-link" aria-label="Direct link to Potential next steps" title="Direct link to Potential next steps">‚Äã</a></h3>
<p><strong>üîÆ Hot reloading of the module when the script or model file changes</strong></p>
<p>The above is a bit tricky as it creates a dependency between the loading code, an async file watcher, and the main render loop. I don't yet have a clear vision for how to connect those in a non-intrusive manner, but otherwise would like to add "hot reloading" as a core piece of functionality to make development easier and faster.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Progress]]></title>
        <id>https://raiment-studios.com/blog/2024/08/15/index</id>
        <link href="https://raiment-studios.com/blog/2024/08/15/index"/>
        <updated>2024-08-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Shading placeholder]]></summary>
        <content type="html"><![CDATA[<h4 class="anchor anchorWithStickyNavbar_LWe7" id="shading-placeholder">Shading placeholder<a href="https://raiment-studios.com/blog/2024/08/15/index#shading-placeholder" class="hash-link" aria-label="Direct link to Shading placeholder" title="Direct link to Shading placeholder">‚Äã</a></h4>
<p>Added shading based on world coordinate positions. This was mostly a test of adding new uniforms and vertex shader outputs to the shader program.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-a2021abeb66f43d42d42079ad1385771.png" width="912" height="740" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="voxels">Voxels<a href="https://raiment-studios.com/blog/2024/08/15/index#voxels" class="hash-link" aria-label="Direct link to Voxels" title="Direct link to Voxels">‚Äã</a></h4>
<p>Added a voxel model. Very inefficient at this point, but "correct."</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-1-b54b4c4c2bddf863a6a6bf4fa4742d08.png" width="912" height="740" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="bug-">Bug! üêõ<a href="https://raiment-studios.com/blog/2024/08/15/index#bug-" class="hash-link" aria-label="Direct link to Bug! üêõ" title="Direct link to Bug! üêõ">‚Äã</a></h4>
<p>Tried increasing the resolution and found bugs :)</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-2-68211a8923c91a217601ead4b72db9c4.png" width="912" height="740" class="img_ev3q"></p>
<p><strong>Guess: missing array data?</strong></p>
<p>Manually counting the input data matches the generated positions array and checking against the runtime data...</p>
<ul>
<li><code>4416 voxels * 6 faces/voxel * 8 positions/face =&gt; 105984 positiions</code></li>
<li><code>4416 voxels * 6 faces/voxel * 6 indices/face =&gt; 158976 indices</code></li>
</ul>
<p>...seems correct.</p>
<p><strong>Guess: too many draw calls?</strong></p>
<p>Seems impossible as this is a single mesh.</p>
<p><strong>Investigation: is it always the same voxels that are missing?</strong></p>
<p>Flipping the order of the voxels during generation changes the missing voxels. Not sure what to conclude from this yet.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-3-94fa10ce7967f770d39bc35a2b0db19b.png" width="912" height="740" class="img_ev3q"></p>
<p>Drawing just the Z+ face on the voxels seems to work correctly. The same seems to be true when rendering any one of the six faces.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-4-3340f0f0e4d6aeb1d53e80c014d1e2a6.png" width="912" height="740" class="img_ev3q"></p>
<p>...but if as soon as 3 faces are rendered together, voxels seem to be lost.</p>
<p><strong>Guess: too many indicies</strong></p>
<p>Yup. The code is using <code>u16</code> which has a max representable value of <code>256*256 = 65,536</code>. There are <code>158,976</code> indices.</p>
<p>Changing to a <code>u32</code> index buffer addresses the problem.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-5-50384b0c6cd604dc27521df09b01552b.png" width="912" height="740" class="img_ev3q"></p>
<p><strong>Resolution</strong></p>
<p>Bumping the render code to always use <code>u32</code> seems fine for this stage of development. Using the larger buffer size affords more flexibility, which is a higher priority right now than optimization for memory or performance.</p>
<p>Voxel chunking and optimizing away invisible faces need to be done regardless. After that is done, it should be easier to move back to a <code>u16</code> index buffer.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="a-larger-model">A larger model<a href="https://raiment-studios.com/blog/2024/08/15/index#a-larger-model" class="hash-link" aria-label="Direct link to A larger model" title="Direct link to A larger model">‚Äã</a></h4>
<p>With the bug fixed, here's a sine + cosine generated voxel heightmap of <code>128x128x32</code> resolution.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-6-c86cd101968dff730d604af6a62f54cf.png" width="912" height="740" class="img_ev3q"></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WGPU progress]]></title>
        <id>https://raiment-studios.com/blog/2024/08/12/index</id>
        <link href="https://raiment-studios.com/blog/2024/08/12/index"/>
        <updated>2024-08-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Progress update: have some vertices making it from disk to the screen. That's a cube sitting behind of a "2D" pentagon (not necessarily obvious without lights or shading yet).]]></summary>
        <content type="html"><![CDATA[<p>Progress update: have some vertices making it from disk to the screen. That's a cube sitting behind of a "2D" pentagon (not necessarily obvious without lights or shading yet).</p>
<p>The general task I've been working on is taking the "catch-all" <code>State</code> object from the <a href="https://sotrh.github.io/learn-wgpu/" target="_blank" rel="noopener noreferrer">Learn Wgpu tutorial</a> and refactoring into a rendering architecture. This requires wrangling with lifetimes and data sharing, both in my learning how Rust works as well as how objects work in wgpu.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-1-1eb40d212c07243966a0d680e442c690.png" width="912" height="740" class="img_ev3q"></p>
<p>A bit more progress, getting basic semi-harcoded face shading working.  Also changed the camera axes to a <code>Z+ =&gt; UP</code> system.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-b9d6eb27ed14cb48d2bcdebedcca0991.png" width="912" height="740" class="img_ev3q"></p>
<p>A bit more progress: depth buffering finally enabled and rendering multiple objects.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-2-71bd199888c8e864ae0473b26023046d.png" width="912" height="740" class="img_ev3q"></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Worth reading]]></title>
        <id>https://raiment-studios.com/blog/2024/08/11/index</id>
        <link href="https://raiment-studios.com/blog/2024/08/11/index"/>
        <updated>2024-08-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[-   Arc and Mutex in Rust - useful examples and explanation about thes Rust types]]></summary>
        <content type="html"><![CDATA[<ul>
<li><a href="https://itsallaboutthebit.com/arc-mutex/" target="_blank" rel="noopener noreferrer">Arc and Mutex in Rust</a> - useful examples and explanation about thes Rust types</li>
<li><a href="https://www.reddit.com/r/rust/comments/141ll5b/wgpu_questions_vertex_buffers/" target="_blank" rel="noopener noreferrer">Reddit thread about wgpu buffers</a></li>
<li><a href="https://toji.dev/webgpu-best-practices/buffer-uploads.html" target="_blank" rel="noopener noreferrer">WebGPU Buffer Uploads</a></li>
</ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Following the wgpu tutorial]]></title>
        <id>https://raiment-studios.com/blog/2024/08/10/index</id>
        <link href="https://raiment-studios.com/blog/2024/08/10/index"/>
        <updated>2024-08-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Ramping up on the custom rendering engine by going through the excellent Learn Wgpu tutorial.  There's not much to say that's insightful here, but I find it's nice to create "early days" blog posts and images to highlight progress over time.]]></summary>
        <content type="html"><![CDATA[<p>Ramping up on the custom rendering engine by going through the excellent <a href="https://sotrh.github.io/learn-wgpu/" target="_blank" rel="noopener noreferrer">Learn Wgpu tutorial</a>.  There's not much to say that's insightful here, but I find it's nice to create "early days" blog posts and images to highlight progress over time.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="https://raiment-studios.com/assets/images/image-1-c45aff77a0858fed6b3fb55a28575f0e.png" width="912" height="740" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="i-read-a-comment-along-the-lines-of-wgpu-has-so-much-boilerplate">I read a comment along the lines of "wgpu has so much boilerplate"<a href="https://raiment-studios.com/blog/2024/08/10/index#i-read-a-comment-along-the-lines-of-wgpu-has-so-much-boilerplate" class="hash-link" aria-label="Direct link to I read a comment along the lines of &quot;wgpu has so much boilerplate&quot;" title="Direct link to I read a comment along the lines of &quot;wgpu has so much boilerplate&quot;">‚Äã</a></h4>
<p>Though pedantic, I'd argue wgpu has a lot of <em>configuration</em>. I tend to consider boilerplate code common text that <em>must be</em> repeated to properly structure or specify another piece of <em>non-common</em> configuration or otherwise unique code. (Note: my personal definition is <em>very</em> different from <a href="https://aws.amazon.com/what-is/boilerplate-code/" target="_blank" rel="noopener noreferrer">AWS' definition</a> which portrays "boilerplate" as a positive).  By "must be repeated", I'm alluding to the kind of code that cannot be encapsulated easily into a reusable function, library, or other standard language primitive -- let's ignore macros certainly blur that line and just run with this hand-wavy definition!</p>
<p>In the context of creating <em>many different wgpu programs</em>, I can see how repeating the exact same configuration would constitue a good deal of "boilerplate code." However, that commonality could be easily wrapped into a reusable library, which -- if we're willing to run with my definition of boilerplate code! -- means it is not boilerplate code as the code does not have the quality that it "must be" repeated.</p>
<p>In the context of a single program, wgpu strikes me simply as a very low-level library with detailed, highly structured configuration.</p>]]></content>
    </entry>
</feed>