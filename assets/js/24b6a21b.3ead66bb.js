"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5569],{2745:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=t(4848),s=t(8453);const a={tags:["docusaurus","wasm","rust","bevy","git-lfs"]},o="Bevy WASM rendering",r={permalink:"/blog/2024/10/28/2024-10-28/",editUrl:"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-10-28/2024-10-28.md",source:"@site/blog/2024-10-28/2024-10-28.md",title:"Bevy WASM rendering",description:'A Bevy "lava lamp"',date:"2024-10-28T00:00:00.000Z",tags:[{inline:!0,label:"docusaurus",permalink:"/blog/tags/docusaurus"},{inline:!0,label:"wasm",permalink:"/blog/tags/wasm"},{inline:!0,label:"rust",permalink:"/blog/tags/rust"},{inline:!0,label:"bevy",permalink:"/blog/tags/bevy"},{inline:!0,label:"git-lfs",permalink:"/blog/tags/git-lfs"}],readingTime:4.67,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["docusaurus","wasm","rust","bevy","git-lfs"]},unlisted:!1,prevItem:{title:"guidebook-outline prototype",permalink:"/blog/2024/10/29/2024-10-29/"},nextItem:{title:"Voxel shader",permalink:"/blog/2024/09/04/index"}},l={authorsImageUrls:[]},d=[{value:"Letting the browser decide the host Element ID",id:"letting-the-browser-decide-the-host-element-id",level:3},{value:"Running the WASM code in Docusaurus",id:"running-the-wasm-code-in-docusaurus",level:3},{value:"(1) Idempotence",id:"1-idempotence",level:4},{value:"(2) Docusaurus script building/bundling",id:"2-docusaurus-script-buildingbundling",level:4},{value:"Workaround",id:"workaround",level:4},{value:"An aside of GitHub Large File Storage (LFS)",id:"an-aside-of-github-large-file-storage-lfs",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{style:{float:"right",marginLeft:32,display:"flex",flexDirection:"column"},children:[(0,i.jsx)("img",{src:t(1969).A,style:{maxWidth:200}}),(0,i.jsx)("div",{style:{textAlign:"center"},children:(0,i.jsx)("small",{children:'A Bevy "lava lamp"'})})]}),"\n",(0,i.jsx)(n.p,{children:"Added an experiment of rendering with Bevy using WASM. It's nothing too exciting as I'm new to Bevy, WASM, and still relatively inexperienced with Rust!"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/snowfall/demos/wasm-canvas/",children:"Demo page here"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:"A few notes on the development:"}),"\n",(0,i.jsx)(n.h3,{id:"letting-the-browser-decide-the-host-element-id",children:"Letting the browser decide the host Element ID"}),"\n",(0,i.jsxs)(n.p,{children:['I wanted to host this experiment (and future ones) within the context of pages within the Docusaurus app. I certainly do not know the "best" way to do this yet, but one definite constraint to pass the canvas ',(0,i.jsx)(n.code,{children:"id"})," to the WASM module at startup rather than hard-coding it in the WASM and browser."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"As far as I can tell"}),", the WASM ",(0,i.jsx)(n.code,{children:"init"})," function does not take arguments, therefore the startup is exposed via a separate ",(0,i.jsx)(n.code,{children:"wasm_bindgen"})," exported function called ",(0,i.jsx)(n.code,{children:"start"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In the Rust snippet below, you can see we do nothing in ",(0,i.jsx)(n.code,{children:"main"})," and explicitly pass in an ",(0,i.jsx)(n.code,{children:"id"})," to the ",(0,i.jsx)(n.code,{children:"WindowPlugin"})," in a separate ",(0,i.jsx)(n.code,{children:"start"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    // The run() entrypoint does the work as it can be called\n    // from the browser with parameters.\n}\n\n#[wasm_bindgen]\npub fn start(canvas_id: &str) {\n    let id = format!("#{}", canvas_id);\n\n    App::new()\n        .add_plugins(DefaultPlugins.set(WindowPlugin {\n            primary_window: Some(Window {\n                canvas: Some(id.into()),\n                ..default()\n            }),\n            ..default()\n        }))\n        .add_systems(Startup, setup)\n        .add_systems(\n            Update,\n            (\n                move_ball, //\n                update_transforms,\n            ),\n        )\n        .run();\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The JavaScript code to bootstrap this looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const go = async () => {\n    let mod = await import(moduleName);\n    await mod.default();\n    await mod.start(canvasID);\n};\ngo();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But admittedly the above is ",(0,i.jsx)(n.em,{children:"not"})," the actual JavaScript code for hosting the WASM module..."]}),"\n",(0,i.jsx)(n.h3,{id:"running-the-wasm-code-in-docusaurus",children:"Running the WASM code in Docusaurus"}),"\n",(0,i.jsx)(n.admonition,{title:"Disclaimer",type:"warning",children:(0,i.jsx)(n.p,{children:'This is workaround code. It "works" but I\'m sure there is a correct way to handle this that I was not able to discover!'})}),"\n",(0,i.jsx)(n.h4,{id:"1-idempotence",children:"(1) Idempotence"}),"\n",(0,i.jsxs)(n.p,{children:["There's something I don't understand about WASM module loading and, more importantly, reloading/reuse. This is problematic in the context of a Single Page Application (SPA) like Docusaurus where if you navigate to page ABC, then to page XYZ, then back to ABC, any initialization that happened on the first visit to page ABC will happen again on the second visit. In other words, I'm not sure how to make the WASM initalization ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Idempotence",children:(0,i.jsx)(n.strong,{children:"idempotent"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:"If there's a correct way to..."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reuse a WASM module that's already loaded"}),"\n",(0,i.jsx)(n.li,{children:"Unload a WASM module on navigation away from the page"}),"\n",(0,i.jsx)(n.li,{children:"Reload a WASM module"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"...I'd enjoy learning how!"}),"\n",(0,i.jsx)(n.h4,{id:"2-docusaurus-script-buildingbundling",children:"(2) Docusaurus script building/bundling"}),"\n",(0,i.jsxs)(n.p,{children:["Docusaurus also has logic for renaming, bundling, rewriting, etc. JavaScript code used on the pages. I'm not sure what the exact logic of what it does, but end of the day, I ",(0,i.jsx)(n.em,{children:"did not want"})," Docusaurus manipulating the JS generated by the WASM build process."]}),"\n",(0,i.jsx)(n.p,{children:"Admittedly this is a bit of laziness on my part for not really understanding what Docusaurus does and how best to circumvent it."}),"\n",(0,i.jsx)(n.h4,{id:"workaround",children:"Workaround"}),"\n",(0,i.jsx)(n.p,{children:"I worked around the reload problems and script mangling with a custom MDX Component in Docusaurus that:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Directly injects a ",(0,i.jsx)(n.code,{children:"<script>"})," element so Docusaurus can't modify what it does"]}),"\n",(0,i.jsx)(n.li,{children:"Uses a hacky exception handler to reload the page if the WASM seems to fail (usually what happens on the second visit to the page without an intermittent reload)"}),"\n",(0,i.jsx)(n.li,{children:"Sets a retry limit in case the logic for (2) is not right in all cases (because this is a hacky workaround, not robust code so precautions against an infinite loop are important!)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export function CanvasWASM({\n    id,\n    module,\n    width,\n    height,\n    style,\n}: {\n    id: string,\n    module: string,\n    width: number,\n    height: number,\n    style?: React.CSSProperties,\n}) {\n    React.useEffect(() => {\n        // We create a a DOM element since Docusaurus ends up renaming /\n        // changing the JS file to load the WASM which breaks the import\n        // in production.  This is pretty hacky but it works (for now).\n        const script = document.createElement('script');\n        script.type = 'module';\n        script.text = `            \nlet key = 'wasm-retry-count-${module}-${id}';\nlet success = setTimeout(function() {\n    localStorage.setItem(key, \"0\");\n}, 3500);\n\nconst go = async () => {\n    try {       \n        let mod = await import('${module}');\n        await mod.default();\n        await mod.start('${id}');\n        localStorage.setItem(key, \"0\");\n    } catch (e) {     \n        if (e.message == \"unreachable\") {        \n            clearTimeout(success);\n            let value = parseInt(localStorage.getItem(key) || \"0\", 10);\n            if (value < 10) {                \n                console.log(\"WASM error, retry attempt: \", value);\n                setTimeout(function() {\n                    localStorage.setItem(key, (value + 1).toString());\n                    window.location.reload();\n                }, 20 + 100 * value);\n            } else {\n                throw e;\n            }\n        }\n    }\n};\ngo();\n            `.trim();\n        document.body.appendChild(script);\n    }, []);\n\n    return <canvas id={id} width={width} height={height} style={style}></canvas>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"an-aside-of-github-large-file-storage-lfs",children:"An aside of GitHub Large File Storage (LFS)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"In case anyone on the internet runs into this and stumbles upon this page..."})}),"\n",(0,i.jsx)(n.p,{children:"I also wasted quite a bit of time on this problem:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"I publish this site using GitHub Pages"}),"\n",(0,i.jsxs)(n.li,{children:["I generally set a ",(0,i.jsx)(n.code,{children:".gitattributes"})," file in all my repos to store generated files using git LFS"]}),"\n",(0,i.jsxs)(n.li,{children:["I have an entry for ",(0,i.jsx)(n.code,{children:"*.wasm"})," to store those in LFS"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"GitHub Pages doesn't use LFS when serving the files"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This meant my code was working locally but when I was trying to load the WASM files on the published site, ",(0,i.jsx)(n.em,{children:'the LFS "pointer" text file was being served rather than the binary WASM file itself'}),". It took me a while to figure this out. Ultimately the fix was to remove the ",(0,i.jsx)(n.code,{children:".gitattributes"})," from the GitHub Pages repo so LFS is ",(0,i.jsx)(n.em,{children:"not"})," used on the published site. (Aside: this might be a good reason to consider hosting this site via another platform, but I'll leave that for another day!)"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1969:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/image-7666d1b301834119217aaaff17aa571f.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);