"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[693],{9415:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>f,frontMatter:()=>l,metadata:()=>d,toc:()=>h});var i=t(4848),s=t(8453),r=(t(6540),t(5195));const a={tableOfContentsInline:"tableOfContentsInline_prmo"};function o(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:s}=e;return(0,i.jsx)("div",{className:a.tableOfContentsInline,children:(0,i.jsx)(r.A,{toc:n,minHeadingLevel:t,maxHeadingLevel:s,className:"table-of-contents",linkClassName:null})})}const l={},c="WGPU Architecture",d={id:"snowfall/tutorials/wgpu-architecture",title:"WGPU Architecture",description:"-   This is a work-in-progress draft",source:"@site/docs/snowfall/800-tutorials/810-wgpu-architecture.mdx",sourceDirName:"snowfall/800-tutorials",slug:"/snowfall/tutorials/wgpu-architecture",permalink:"/docs/snowfall/tutorials/wgpu-architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/docs/snowfall/800-tutorials/810-wgpu-architecture.mdx",tags:[],version:"current",sidebarPosition:810,frontMatter:{},sidebar:"snowfallSidebar",previous:{title:"Engine",permalink:"/docs/snowfall/engine"},next:{title:"References",permalink:"/docs/snowfall/references"}},u={},h=[{value:"Concepts",id:"concepts",level:2},{value:"Scene data",id:"scene-data",level:2},{value:"Load from file",id:"load-from-file",level:3},{value:"Scene &amp; renderer independence",id:"scene--renderer-independence",level:3},{value:"RenderTree",id:"rendertree",level:3},{value:"User input",id:"user-input",level:2},{value:"Action Queue",id:"action-queue",level:3}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"wgpu-architecture",children:"WGPU Architecture"})}),"\n",(0,i.jsxs)(n.admonition,{title:"Disclaimer!",type:"danger",children:[(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"This is a work-in-progress draft"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"I am not a WGPU expert"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"I am not a rendering engine architecture expert"})}),"\n"]}),(0,i.jsx)(n.p,{children:"These are notes that I hope to update and improve incrementally until the point at\nwhich this is sufficiently valuable and correct to remove this warning!!!"})]}),"\n",(0,i.jsx)("h3",{children:"Introduction"}),"\n",(0,i.jsx)("img",{style:{maxWidth:"40%",float:"right",padding:"0 16px 12px"},src:t(4982).A}),"\n",(0,i.jsxs)(n.p,{children:["This tutorial is intended as a follow-on to the excellent ",(0,i.jsx)(n.a,{href:"https://sotrh.github.io/learn-wgpu/",children:"Learn WGPU tutorial"}),". Whereas that tutorial focuses on ",(0,i.jsx)(n.em,{children:"the use of WGPU"}),", this tutorial aims to help ",(0,i.jsx)(n.strong,{children:"organize the rendering code"})," to make for more a flexible, maintainable, and easy to expand rendering architecture."]}),"\n",(0,i.jsx)("h3",{children:"Table of contents"}),"\n",(0,i.jsx)("div",{style:{paddingLeft:"2rem"},children:(0,i.jsx)(o,{toc:h})}),"\n",(0,i.jsx)("div",{style:{clear:"both "}}),"\n",(0,i.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,i.jsxs)(n.p,{children:["This tutorial aims to call out the ",(0,i.jsx)(n.em,{children:"conceptually"}),' independent (or at least separable) parts of a rendering engine so that the overall code structure is easier to understand. These are the "objects" we want to think about that exist regardless of ',(0,i.jsx)(n.em,{children:"how they are implemented"}),"."]}),"\n",(0,i.jsx)(n.admonition,{title:"Example",type:"note",children:(0,i.jsx)(n.p,{children:'We know our engine will have some sort of materials we want to render objects with. Therefore, "Material" is called out here. Contrastingly, we do not call out "shader programs" here as this is more an aspect of "how" the concept of a Material is handled in WGPU.'})}),"\n",(0,i.jsx)(n.p,{children:"Let's start with a very loose list of the conceptual objects in a rendering engine:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Scene","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Camera"}),"\n",(0,i.jsx)(n.li,{children:"Lights"}),"\n",(0,i.jsxs)(n.li,{children:["Instances","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Models","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Geometry"}),"\n",(0,i.jsx)(n.li,{children:"Material"}),"\n",(0,i.jsx)(n.li,{children:"Transforms"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Renderer"}),"\n",(0,i.jsx)(n.li,{children:"User input"}),"\n",(0,i.jsxs)(n.li,{children:["Frame loop","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Actions"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"File formats"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"What is a core concept versus what is an implementation detail is a sliding scale that depends on what you want to expose to the user of the engine! If your engine provides fine-grained control of shader programs to the user as major feature of the engine, then perhaps shader programs are a core concept. The above is only one take on the topic."})}),"\n",(0,i.jsx)(n.h2,{id:"scene-data",children:"Scene data"}),"\n",(0,i.jsx)(n.h3,{id:"load-from-file",children:"Load from file"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Avoid hard-coded scene data"}),"\n",(0,i.jsx)(n.li,{children:"Allow transform of user-friendly, editor-friendly, or standard formats"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scene--renderer-independence",children:"Scene & renderer independence"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maintenance benefits"}),"\n",(0,i.jsx)(n.li,{children:"Decouple concerns"}),"\n",(0,i.jsx)(n.li,{children:"Con: copying of data"}),"\n",(0,i.jsx)(n.li,{children:'Con: update multiple places for a "single" change'}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"rendertree",children:"RenderTree"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Shadow data structure"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"user-input",children:"User input"}),"\n",(0,i.jsx)(n.h3,{id:"action-queue",children:"Action Queue"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Decouple input from action"}),"\n",(0,i.jsx)(n.li,{children:"Make features like custom key bindings easier"}),"\n",(0,i.jsx)(n.li,{children:"Process actions are a well-known, easy to understand point in the rendering pipeline"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::{collections::HashMap, sync::Mutex};\n\n#[derive(Clone)]\npub enum Action {\n    MoveForward(f32),\n    MoveBackward(f32),\n    MoveRight(f32),\n    MoveLeft(f32),\n}\n\nimpl Action {\n    pub fn to_type(&self) -> &\'static str {\n        match self {\n            Action::MoveForward(_) => "MoveForward",\n            Action::MoveBackward(_) => "MoveBackward",\n            Action::MoveRight(_) => "MoveRight",\n            Action::MoveLeft(_) => "MoveLeft",\n        }\n    }\n}\n\n// The ActionQueue handles actions in three categories:\n//\n// 1. **Independent actions**: these are enqueued and processed during the frame\n//    update. These are the simplest.  The action queue ensures the processing\n//    occurs at a well-defined time in the frame loop.\n//\n// 2. **Frame actions**: at most one action of a given type is allowed per frame.\n//    Multiple calls to enqueue frame actions of the same type will result in the\n//    most recent action replacing the last.  This is useful for actions such as\n//    those cased by user-input where multiple inputs in a single frame need to be\n//    reduced to at most a single action to be process in the frame.\n//\n// 3. **Persisted actions**: action types that once put in the queue remain in the\n//    queue to be processed every frame until they are explicitly removed. This is\n//    useful for toggle state actions.\n//\npub struct ActionQueue {\n    queue: Vec<Action>,\n    frame_queue: HashMap<String, Action>,\n    persist_queue: HashMap<String, Action>,\n}\n\nimpl ActionQueue {\n    pub fn new() -> ActionQueue {\n        ActionQueue {\n            queue: Vec::new(),\n            frame_queue: HashMap::new(),\n            persist_queue: HashMap::new(),\n        }\n    }\n\n    pub fn enqueue(&mut self, action: Action) {\n        self.queue.push(action);\n    }\n\n    // Ensures at most one of the action type is in the queue for a\n    // given frame. Subsequent calls replace prior actions of the same type.\n    pub fn enqueue_frame(&mut self, action: Action) {\n        self.frame_queue\n            .insert(action.to_type().to_string(), action);\n    }\n\n    pub fn toggle_persist(&mut self, action: Action, enable: bool) {\n        let key = action.to_type();\n        if enable {\n            self.persist_queue.insert(key.to_string(), action);\n        } else {\n            self.persist_queue.remove(key);\n        }\n    }\n\n    // Drains all one-time actions and frame actions, clones all\n    // persistent actions.\n    pub fn drain_actions_for_frame(&mut self) -> Vec<Action> {\n        let mut actions = Vec::new();\n        actions.extend(self.queue.drain(..));\n        actions.extend(self.frame_queue.drain().map(|(_, v)| v));\n        actions.extend(self.persist_queue.values().cloned());\n        actions\n    }\n}\n'})})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},5195:(e,n,t)=>{t.d(n,{A:()=>p});var i=t(6540),s=t(6342);function r(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),t=Array(7).fill(-1);n.forEach(((e,n)=>{const i=t.slice(2,e.level);e.parentIndex=Math.max(...i),t[e.level]=n}));const i=[];return n.forEach((e=>{const{parentIndex:t,...s}=e;t>=0?n[t].children.push(s):i.push(s)})),i}function a(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:i}=e;return n.flatMap((e=>{const n=a({toc:e.children,minHeadingLevel:t,maxHeadingLevel:i});return function(e){return e.level>=t&&e.level<=i}(e)?[{...e,children:n}]:n}))}function o(e){const n=e.getBoundingClientRect();return n.top===n.bottom?o(e.parentNode):n}function l(e,n){let{anchorTopOffset:t}=n;const i=e.find((e=>o(e).top>=t));if(i){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(o(i))?i:e[e.indexOf(i)-1]??null}return e[e.length-1]??null}function c(){const e=(0,i.useRef)(0),{navbar:{hideOnScroll:n}}=(0,s.p)();return(0,i.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function d(e){const n=(0,i.useRef)(void 0),t=c();(0,i.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:i,linkActiveClassName:s,minHeadingLevel:r,maxHeadingLevel:a}=e;function o(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(i),o=function(e){let{minHeadingLevel:n,maxHeadingLevel:t}=e;const i=[];for(let s=n;s<=t;s+=1)i.push(`h${s}.anchor`);return Array.from(document.querySelectorAll(i.join()))}({minHeadingLevel:r,maxHeadingLevel:a}),c=l(o,{anchorTopOffset:t.current}),d=e.find((e=>c&&c.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,t){t?(n.current&&n.current!==e&&n.current.classList.remove(s),e.classList.add(s),n.current=e):e.classList.remove(s)}(e,e===d)}))}return document.addEventListener("scroll",o),document.addEventListener("resize",o),o(),()=>{document.removeEventListener("scroll",o),document.removeEventListener("resize",o)}}),[e,t])}var u=t(8774),h=t(4848);function m(e){let{toc:n,className:t,linkClassName:i,isChild:s}=e;return n.length?(0,h.jsx)("ul",{className:s?void 0:t,children:n.map((e=>(0,h.jsxs)("li",{children:[(0,h.jsx)(u.A,{to:`#${e.id}`,className:i??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,h.jsx)(m,{isChild:!0,toc:e.children,className:t,linkClassName:i})]},e.id)))}):null}const f=i.memo(m);function p(e){let{toc:n,className:t="table-of-contents table-of-contents__left-border",linkClassName:o="table-of-contents__link",linkActiveClassName:l,minHeadingLevel:c,maxHeadingLevel:u,...m}=e;const p=(0,s.p)(),x=c??p.tableOfContents.minHeadingLevel,g=u??p.tableOfContents.maxHeadingLevel,v=function(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:s}=e;return(0,i.useMemo)((()=>a({toc:r(n),minHeadingLevel:t,maxHeadingLevel:s})),[n,t,s])}({toc:n,minHeadingLevel:x,maxHeadingLevel:g});return d((0,i.useMemo)((()=>{if(o&&l)return{linkClassName:o,linkActiveClassName:l,minHeadingLevel:x,maxHeadingLevel:g}}),[o,l,x,g])),(0,h.jsx)(f,{toc:v,className:t,linkClassName:o,...m})}},4982:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/image-9d9121b5f36cbcfd811a05eb44fe32f5.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);