"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9356],{2107:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>a});var t=o(4848),i=o(8453);const s={},r="Collision detection",c={id:"snowfall/architecture/collisions",title:"Collision detection",description:"These are just notes, not a write-up yet!",source:"@site/docs/snowfall/400-architecture/444-collisions.md",sourceDirName:"snowfall/400-architecture",slug:"/snowfall/architecture/collisions",permalink:"/docs/snowfall/architecture/collisions",draft:!1,unlisted:!1,editUrl:"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/docs/snowfall/400-architecture/444-collisions.md",tags:[],version:"current",sidebarPosition:444,frontMatter:{},sidebar:"snowfallSidebar",previous:{title:"Scene loading",permalink:"/docs/snowfall/architecture/scene-loading"},next:{title:"Engine",permalink:"/docs/snowfall/architecture/engine"}},l={},a=[{value:"Applying forces, accounting for position &amp; velocity",id:"applying-forces-accounting-for-position--velocity",level:4},{value:"Detecting collisions of points",id:"detecting-collisions-of-points",level:4}];function p(e){const n={admonition:"admonition",code:"code",h1:"h1",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"collision-detection",children:"Collision detection"})}),"\n",(0,t.jsx)(n.admonition,{title:"Work in progress",type:"warning",children:(0,t.jsx)(n.p,{children:"These are just notes, not a write-up yet!"})}),"\n",(0,t.jsx)(n.h4,{id:"applying-forces-accounting-for-position--velocity",children:"Applying forces, accounting for position & velocity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    reset force of all objects to 0 at start of frame\n    other actors like gravity apply instantaneous force\n        i.e. add their force each object that should get it\n    a = F / m\n    v' = v + a * dt\n    p' = p + v' * dt\n"})}),"\n",(0,t.jsx)(n.p,{children:"Position and velocity need to be retained between frames. Acceleration is recomputed every frame as is force (which is just acceleration proportional to mass)."}),"\n",(0,t.jsx)(n.h4,{id:"detecting-collisions-of-points",children:"Detecting collisions of points"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"pv = position in voxel coordinates\ntv = target in voxel coordiantes\n\npos = pv\nline = compute 3d bresenham (pv -> tv)\nfor each step of line (p -> q)\n    if q is occupied\n        break\n    else\n        pos = q\n\n# pos now holds the last position in the line that is\n# unoccupied, but it's in voxel space\nif pos == pv\n    pos should keep original position fraction\nelse if pos == tv\n    pos should get target position fraction\nelse\n    put in the center of the voxel at pos\n\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Or should it not use bresenham's because we're okay and might even want it to \"skip over\" corners of voxels? I.e. allow a step to move through voxels for small amounts"}),"\n",(0,t.jsx)(n.li,{children:"Or do we need to use a capsulte shape and point tests are not going to be sufficient?"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>c});var t=o(6540);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);