"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7156],{6616:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>n,metadata:()=>r,toc:()=>h});var o=s(4848),i=s(8453);const n={},a="Design doc",r={id:"guidebook/design-doc",title:"Design doc",description:"Vision",source:"@site/docs/guidebook/100-design-doc.md",sourceDirName:"guidebook",slug:"/guidebook/design-doc",permalink:"/docs/guidebook/design-doc",draft:!1,unlisted:!1,editUrl:"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/docs/guidebook/100-design-doc.md",tags:[],version:"current",sidebarPosition:100,frontMatter:{},sidebar:"guidebookSidebar",previous:{title:"Guidebook",permalink:"/docs/guidebook/"},next:{title:"Mocks",permalink:"/docs/guidebook/mocks/"}},d={},h=[{value:"Vision",id:"vision",level:2},{value:"Design principles",id:"design-principles",level:2},{value:"Appendix",id:"appendix",level:2},{value:"Notes",id:"notes",level:3},{value:"Tags as schema composition",id:"tags-as-schema-composition",level:4},{value:"Tasks change as work progresses",id:"tasks-change-as-work-progresses",level:4}];function c(e){const t={em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"design-doc",children:"Design doc"})}),"\n",(0,o.jsx)(t.h2,{id:"vision",children:"Vision"}),"\n",(0,o.jsx)(t.p,{children:"TODO"}),"\n",(0,o.jsx)(t.h2,{id:"design-principles",children:"Design principles"}),"\n",(0,o.jsx)(t.p,{children:"TODO"}),"\n",(0,o.jsx)(t.h2,{id:"appendix",children:"Appendix"}),"\n",(0,o.jsx)(t.h3,{id:"notes",children:"Notes"}),"\n",(0,o.jsx)(t.h4,{id:"tags-as-schema-composition",children:"Tags as schema composition"}),"\n",(0,o.jsxs)(t.p,{children:['A tag could represent a schema. An item always have a name and zero or more tags. When a tag, say "book" is added to an item, it inherits the schema of that tag. When viewing a tag, it\'s schema can be edited. So "book" gets a title',":string",", author",":string",", date_read",":date",' schema (for example). This implicitly adds fields of "book',":title",'", "book',":author",'", etc. to the item that has the tag "book". In the UI, these appear as "title" and "author" unless there is a name collision with another schema.']}),"\n",(0,o.jsx)(t.p,{children:"A view of a tag would be a table / collection view of all items with that schema, showing the fields. The page also allows updating the schema."}),"\n",(0,o.jsx)(t.h4,{id:"tasks-change-as-work-progresses",children:"Tasks change as work progresses"}),"\n",(0,o.jsxs)(t.p,{children:["TL;DR: seems like Guidebook should allow tasks to be modified ",(0,o.jsx)(t.em,{children:"somewhat"})," fluidly as a project progress, BUT there needs to be some degree of notification?"]}),"\n",(0,o.jsx)(t.p,{children:"For any task with uncertainty, the exact tasks to do change as the work evolves and it's more clear what needs to be done. (The same is true for the goals of the project, but we'll ignore that for these notes.)"}),"\n",(0,o.jsxs)(t.p,{children:["For communication purposes, if the work is being done solo, the content of the tasks shouldn't really matter and thus changing this doesn't matter. The only purposes of recording the work is to help breakdown tasks and ensure key tasks are not fogotten. For team work (or even solo work in a broader architecture), ",(0,o.jsx)(t.em,{children:"some"})," task changes may matter due to implicit architectural impact (e.g. deciding to use a binary format rather than text format because it's faster might contradict other work that anticipates a text format for ease of user editing)."]}),"\n",(0,o.jsx)(t.p,{children:"So what matters when tasks change are:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Architectural functionality that..","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Is being added"}),"\n",(0,o.jsx)(t.li,{children:"Removed"}),"\n",(0,o.jsx)(t.li,{children:"Changed"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.li,{children:"Functionality changes visible to the user"}),"\n",(0,o.jsxs)(t.li,{children:["Limitations","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Added that affect the user or developer"}),"\n",(0,o.jsx)(t.li,{children:"Removed that affect the user or developer"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:'Possibly the Guidebook data model could make Product and Architectural "Requirements" that, if any of these are Added, Removed, or Modified, then an update needs to be added to the Decision Log and this sends out timestamped notifications to Stakeholders. The UI/UX should make this as implicit as possible. If something doesn\'t change any of those, then no additional overhead should be incurred for the user.'}),"\n",(0,o.jsx)(t.p,{children:"Each Requirement theoretically has a category (i.e. Product, Design, Architecture, Marketing, etc.) beyond just the Product or Engineering categorizations."})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var o=s(6540);const i={},n=o.createContext(i);function a(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);