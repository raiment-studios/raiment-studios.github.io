"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6971],{2032:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=n(4848),s=n(8453);const a={},o="WIP: voxel chunking",r={permalink:"/blog/2024/08/21/index",editUrl:"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-21/index.md",source:"@site/blog/2024-08-21/index.md",title:"WIP: voxel chunking",description:"A very work-in-progress implementation of voxel chunking and generation.",date:"2024-08-21T00:00:00.000Z",tags:[],readingTime:3.615,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,prevItem:{title:"Render passes",permalink:"/blog/2024/08/22/index"},nextItem:{title:"Plugins as dylibs",permalink:"/blog/2024/08/20/index"}},l={authorsImageUrls:[]},d=[{value:"Update 3: &quot;Optimizations&quot;",id:"update-3-optimizations",level:4},{value:"Update 2: slow, but headed in the right direction",id:"update-2-slow-but-headed-in-the-right-direction",level:4},{value:"Update with more progress",id:"update-with-more-progress",level:4},{value:"Pseudo-code",id:"pseudo-code",level:4},{value:"Work-in-progress",id:"work-in-progress",level:4},{value:"End-to-end functionality first",id:"end-to-end-functionality-first",level:4},{value:"Performance fix",id:"performance-fix",level:4}];function c(e){const t={code:"code",h4:"h4",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"A very work-in-progress implementation of voxel chunking and generation."}),"\n",(0,i.jsx)(t.h4,{id:"update-3-optimizations",children:'Update 3: "Optimizations"'}),"\n",(0,i.jsxs)(t.p,{children:["After thinking about what I need to optimzie for a bit, I realized I was still running everything as debug build! ","\ud83e\udd26\u200d\u2642\ufe0f"]}),"\n",(0,i.jsx)("video",{loop:!0,controls:!0,muted:"true",autoplay:"true",src:"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+14-58-34.mp4"}),"\n",(0,i.jsx)(t.h4,{id:"update-2-slow-but-headed-in-the-right-direction",children:"Update 2: slow, but headed in the right direction"}),"\n",(0,i.jsx)("video",{loop:!0,controls:!0,muted:"true",autoplay:"true",src:"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+13-19-32.mp4"}),"\n",(0,i.jsx)(t.h4,{id:"update-with-more-progress",children:"Update with more progress"}),"\n",(0,i.jsx)("video",{src:"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+12-10-49.mp4",loop:!0,controls:!0,muted:"true",autoplay:"true"}),"\n",(0,i.jsx)(t.h4,{id:"pseudo-code",children:"Pseudo-code"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Cache\n    entries : Map<Cell position, Entry>\n\nEntry\n    timestamp\n    instance_id\n\nupdate_cells:\n    compute a NxNxM bounds around the camera\n    transform the corners to cell coordinates\n        cells are 32x32x8\n\n    scan each cell in the bounds\n        if cache[cell coords] is empty\n            add a new entry\n        entry.timestamp = now\n\n    for each cache entry\n        if entry.timestamp > AGE\n            remove instance.id from scene\n            drop entry\n        else if entry has no model instance\n            instance = call generator(cell bounds)\n            entry.id = instance.id\n            add instance to scene\n"})}),"\n",(0,i.jsx)(t.h4,{id:"work-in-progress",children:"Work-in-progress"}),"\n",(0,i.jsx)(t.p,{children:"The below gets the basic pseudo-code going, which was the goal. It has a number of issues, which were intentionally deferred to be addressed later:"}),"\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Hook in a real terrain generator function"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Improve the Potentially Visible Set (PVS) code - the fixed bounds around the camera seems a bit too brute force"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Cell cache","\n",(0,i.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Address stuttering - rhe load/discard adds and removes many tiles at once. Seems like it would benefit from spreading out the load and/or somehow being smarter about the load/discard process."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","General performance - does a lot of work already and seems slow. Need to look into what kind of unnecessary work it is doing. Do that research before deciding what code changes are needed."]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ",'The generator simply clones a fixed tile instance. It\'s not a "real" generator']}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","The load/discard of new tiles has a lot of stutter as many tiles get added / removed at once"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","The potential visible set bounds are intentionally small for debugging"]}),"\n",(0,i.jsxs)(t.li,{className:"task-list-item",children:[(0,i.jsx)(t.input,{type:"checkbox",disabled:!0})," ","General performance: this does a lot of work, which doesn't seem scalable without refinement"]}),"\n"]}),"\n",(0,i.jsx)("video",{style:{width:"100%"},src:"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+09-21-58.mov",controls:"controls",muted:"muted",class:"d-block rounded-bottom-2 border-top width-fit"}),"\n",(0,i.jsx)(t.h4,{id:"end-to-end-functionality-first",children:"End-to-end functionality first"}),"\n",(0,i.jsx)(t.p,{children:"A bit about how I approach new work where I personally don't know exactly what needs to be done."}),"\n",(0,i.jsx)(t.p,{children:"Note that step (2c) is (surprisingly?) often the easiest step to ignore yet the most beneficial to do well in terms of it's impact of understanding the problem space and implementating something both quickly but also future-friendly."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'1. Define the result\n\n2. Get it working\n    a. Define the high-level approach\n    b. Implement a rough end-to-end pipeline\n    c. Proxy as many details as possible (i.e. use the simplest\n       implementation I can that still is representative of what\n       I eventually want)\n\n3. Rinse-and-repeat step 2 until it works\n\n4. Make it better\n    a. Replace proxies with real implementations\n    b. Fill in details\n\n5. Scope to "good enough"\n    a. Repeat 4 until it feels "complete" even if it\'s not what I\n       fully wanted in 1\n    b. Recognize\n\n5. Code clean-up\n    a. Remember I won\'t remember what I had been thinking even a\n       week later, so code comments, naming, and general clean-up\n       are worth it\n\n6. Write-up\n    a. Write a light summary of what I did. This highlights what I may\n       have missed especially around (1), (2a), and (5)\n    b. Write out the next todos to make it possible to pick up where\n       I left off later\n'})}),"\n",(0,i.jsx)(t.p,{children:"In this particular case, looking at step (2c) the keys to getting something going were:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Cloning a fixed instance rather than using a real, position dependent terrain generator"}),"\n",(0,i.jsx)(t.li,{children:"Making that fixed instance something very simple"}),"\n",(0,i.jsx)(t.li,{children:"Making the potentially visible set logic very simple (just a fixed bounds)"}),"\n",(0,i.jsx)(t.li,{children:"Ignoring performance until I got it functionally working"}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"performance-fix",children:"Performance fix"}),"\n",(0,i.jsx)(t.p,{children:"Figured out part of the performance issues:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"I had incorrectly assumed dropping stale tiles would be fast; it wasn't"}),"\n",(0,i.jsx)(t.li,{children:"Dropped instances could be anywhere in the instance list"}),"\n",(0,i.jsx)(t.li,{children:"The re-sync code was written such that any mismatch implicitly invalidated everything after it in the list"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The fix was to hash the existing instance IDs and check for against that unordered table rather than continuing the very simple prior logic which assumed indicies always aligned."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);