"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2024/11/16/2024-11-16/","metadata":{"permalink":"/blog/2024/11/16/2024-11-16/","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-11-16/2024-11-16.md","source":"@site/blog/2024-11-16/2024-11-16.md","title":"Voxel brushes","description":"Dug a tunnel into the side of the mountain...","date":"2024-11-16T00:00:00.000Z","tags":[{"inline":true,"label":"voxels","permalink":"/blog/tags/voxels"},{"inline":true,"label":"bevy","permalink":"/blog/tags/bevy"},{"inline":true,"label":"brushes","permalink":"/blog/tags/brushes"},{"inline":true,"label":"terrain","permalink":"/blog/tags/terrain"},{"inline":true,"label":"editing","permalink":"/blog/tags/editing"}],"readingTime":0.405,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["voxels","bevy","brushes","terrain","editing"]},"unlisted":false,"nextItem":{"title":"More voxels","permalink":"/blog/2024/11/13/2024-11-13/"}},"content":"Dug a tunnel into the side of the mountain...\\n\\n![alt text](image.png)\\n\\nThe engine now supports brushes for adding, removing, and painting multiple voxels at once.\\n\\n![alt text](image-0.png)\\n\\nAlso added a micro heads up display at the bottom so toggling between voxel types and brushes is not _fully_ an exercise in memorization.\\n\\nThere are still a few bugs and, now with larger persisted worlds, the frames-per-second (fps) is quickly dropping out of the ~60 range. Nonetheless, the engine is feeling more capable."},{"id":"/2024/11/13/2024-11-13/","metadata":{"permalink":"/blog/2024/11/13/2024-11-13/","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-11-13/2024-11-13.md","source":"@site/blog/2024-11-13/2024-11-13.md","title":"More voxels","description":"Working a bit on terrain generation. Turns out it can be a lot more fun working on this in native desktop with Rust rather than WebGL given the runtime limitations of the latter.","date":"2024-11-13T00:00:00.000Z","tags":[{"inline":true,"label":"voxels","permalink":"/blog/tags/voxels"},{"inline":true,"label":"terrain","permalink":"/blog/tags/terrain"},{"inline":true,"label":"bevy","permalink":"/blog/tags/bevy"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"}],"readingTime":0.205,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["voxels","terrain","bevy","rust"]},"unlisted":false,"prevItem":{"title":"Voxel brushes","permalink":"/blog/2024/11/16/2024-11-16/"},"nextItem":{"title":"Bevy voxels","permalink":"/blog/2024/11/12/2024-11-12/"}},"content":"Working a bit on terrain generation. Turns out it can be a lot more fun working on this in native desktop with Rust rather than WebGL given the runtime limitations of the latter.\\n\\n![alt text](image.png)\\n\\n![alt text](image-1.png)\\n\\n![alt text](image-2.png)\\n\\n![alt text](image-3.png)"},{"id":"/2024/11/12/2024-11-12/","metadata":{"permalink":"/blog/2024/11/12/2024-11-12/","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-11-12/2024-11-12.md","source":"@site/blog/2024-11-12/2024-11-12.md","title":"Bevy voxels","description":"Still working on voxel rendering in Bevy. Restarted from fresh as I\'ve learned a bit more since last time...","date":"2024-11-12T00:00:00.000Z","tags":[{"inline":true,"label":"voxels","permalink":"/blog/tags/voxels"},{"inline":true,"label":"bevy","permalink":"/blog/tags/bevy"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"}],"readingTime":0.125,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["voxels","bevy","rust"]},"unlisted":false,"prevItem":{"title":"More voxels","permalink":"/blog/2024/11/13/2024-11-13/"},"nextItem":{"title":"Voxelizer","permalink":"/blog/2024/11/07/2024-11-07/"}},"content":"Still working on voxel rendering in Bevy. Restarted from fresh as I\'ve learned a bit more since last time...\\n\\n![alt text](image.png)\\n\\n![alt text](image-1.png)\\n\\n![alt text](image-2.png)"},{"id":"/2024/11/07/2024-11-07/","metadata":{"permalink":"/blog/2024/11/07/2024-11-07/","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-11-07/2024-11-07.md","source":"@site/blog/2024-11-07/2024-11-07.md","title":"Voxelizer","description":"Been working on a lot of different experiments lately. Merging my recent interest in learning Bevy, Rust, and WASM with my long-time interest in voxel rendering, I\'ve been working on an experimental program to convert a Quake 2 BSP38 map file into voxelized representation.","date":"2024-11-07T00:00:00.000Z","tags":[{"inline":true,"label":"voxels","permalink":"/blog/tags/voxels"},{"inline":true,"label":"wasm","permalink":"/blog/tags/wasm"},{"inline":true,"label":"bevy","permalink":"/blog/tags/bevy"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"snowfall","permalink":"/blog/tags/snowfall"},{"inline":true,"label":"quake2","permalink":"/blog/tags/quake-2"},{"inline":true,"label":"bsp38","permalink":"/blog/tags/bsp-38"}],"readingTime":0.35,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["voxels","wasm","bevy","rust","snowfall","quake2","bsp38"]},"unlisted":false,"prevItem":{"title":"Bevy voxels","permalink":"/blog/2024/11/12/2024-11-12/"},"nextItem":{"title":"guidebook-outline prototype","permalink":"/blog/2024/10/29/2024-10-29/"}},"content":"Been working on a lot of different experiments lately. Merging my recent interest in learning Bevy, Rust, and WASM with my long-time interest in voxel rendering, I\'ve been working on an experimental program to convert a Quake 2 BSP38 map file into voxelized representation.\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024_11_07.mp4\\"/>\\n\\nThe above is slow and inefficient, but it\'s an interesting starting point as it\'s all running in WASM using Bevy."},{"id":"/2024/10/29/2024-10-29/","metadata":{"permalink":"/blog/2024/10/29/2024-10-29/","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-10-29/2024-10-29.md","source":"@site/blog/2024-10-29/2024-10-29.md","title":"guidebook-outline prototype","description":"Working on another guidebook-outline prototype.","date":"2024-10-29T00:00:00.000Z","tags":[],"readingTime":0.575,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Voxelizer","permalink":"/blog/2024/11/07/2024-11-07/"},"nextItem":{"title":"Bevy WASM rendering","permalink":"/blog/2024/10/28/2024-10-28/"}},"content":"Working on another `guidebook-outline` prototype.\\n\\nThis loads an outline directly from a GitHub repo (once the user has authenticated with GitHub). The below just a proof of concept.\\n\\nUsing GitHub as the backing store is a fundamental premise for the app as it gives the user complete control over their data.\\n\\n![alt text](image.png)\\n\\nThe next sorts of things to build into the prototype are:\\n\\n-   [ ] Repository selection\\n    -   [ ] Filter by those with the right structure\\n-   [ ] Editable items\\n    -   [ ] With save back to GitHub\\n    -   [ ] With IndexDB caching to throttle GitHub callbacks\\n    -   [ ] With flush to GH on navigation away from the app"},{"id":"/2024/10/28/2024-10-28/","metadata":{"permalink":"/blog/2024/10/28/2024-10-28/","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-10-28/2024-10-28.md","source":"@site/blog/2024-10-28/2024-10-28.md","title":"Bevy WASM rendering","description":"A Bevy \\"lava lamp\\"","date":"2024-10-28T00:00:00.000Z","tags":[{"inline":true,"label":"docusaurus","permalink":"/blog/tags/docusaurus"},{"inline":true,"label":"wasm","permalink":"/blog/tags/wasm"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"bevy","permalink":"/blog/tags/bevy"},{"inline":true,"label":"git-lfs","permalink":"/blog/tags/git-lfs"}],"readingTime":4.67,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["docusaurus","wasm","rust","bevy","git-lfs"]},"unlisted":false,"prevItem":{"title":"guidebook-outline prototype","permalink":"/blog/2024/10/29/2024-10-29/"},"nextItem":{"title":"Voxel shader","permalink":"/blog/2024/09/04/index"}},"content":"<div style={{ float: \\"right\\", marginLeft: 32, display: \\"flex\\", flexDirection: \\"column\\" }}>\\n<img src={require(\\"./image.png\\").default} style={{ maxWidth: 200 }}/>\\n<div style={{ textAlign: \\"center\\" }}><small>A Bevy \\"lava lamp\\"</small></div>\\n</div>\\n\\nAdded an experiment of rendering with Bevy using WASM. It\'s nothing too exciting as I\'m new to Bevy, WASM, and still relatively inexperienced with Rust!\\n\\n**[Demo page here](/docs/snowfall/demos/wasm-canvas/)**.\\n\\nA few notes on the development:\\n\\n### Letting the browser decide the host Element ID\\n\\nI wanted to host this experiment (and future ones) within the context of pages within the Docusaurus app. I certainly do not know the \\"best\\" way to do this yet, but one definite constraint to pass the canvas `id` to the WASM module at startup rather than hard-coding it in the WASM and browser.\\n\\n_As far as I can tell_, the WASM `init` function does not take arguments, therefore the startup is exposed via a separate `wasm_bindgen` exported function called `start`.\\n\\nIn the Rust snippet below, you can see we do nothing in `main` and explicitly pass in an `id` to the `WindowPlugin` in a separate `start` function.\\n\\n```rust\\nfn main() {\\n    // The run() entrypoint does the work as it can be called\\n    // from the browser with parameters.\\n}\\n\\n#[wasm_bindgen]\\npub fn start(canvas_id: &str) {\\n    let id = format!(\\"#{}\\", canvas_id);\\n\\n    App::new()\\n        .add_plugins(DefaultPlugins.set(WindowPlugin {\\n            primary_window: Some(Window {\\n                canvas: Some(id.into()),\\n                ..default()\\n            }),\\n            ..default()\\n        }))\\n        .add_systems(Startup, setup)\\n        .add_systems(\\n            Update,\\n            (\\n                move_ball, //\\n                update_transforms,\\n            ),\\n        )\\n        .run();\\n}\\n```\\n\\nThe JavaScript code to bootstrap this looks like this:\\n\\n```js\\nconst go = async () => {\\n    let mod = await import(moduleName);\\n    await mod.default();\\n    await mod.start(canvasID);\\n};\\ngo();\\n```\\n\\nBut admittedly the above is _not_ the actual JavaScript code for hosting the WASM module...\\n\\n### Running the WASM code in Docusaurus\\n\\n:::warning Disclaimer\\n\\nThis is workaround code. It \\"works\\" but I\'m sure there is a correct way to handle this that I was not able to discover!\\n\\n:::\\n\\n#### (1) Idempotence\\n\\nThere\'s something I don\'t understand about WASM module loading and, more importantly, reloading/reuse. This is problematic in the context of a Single Page Application (SPA) like Docusaurus where if you navigate to page ABC, then to page XYZ, then back to ABC, any initialization that happened on the first visit to page ABC will happen again on the second visit. In other words, I\'m not sure how to make the WASM initalization [**idempotent**](https://en.wikipedia.org/wiki/Idempotence).\\n\\nIf there\'s a correct way to...\\n\\n-   Reuse a WASM module that\'s already loaded\\n-   Unload a WASM module on navigation away from the page\\n-   Reload a WASM module\\n\\n...I\'d enjoy learning how!\\n\\n#### (2) Docusaurus script building/bundling\\n\\nDocusaurus also has logic for renaming, bundling, rewriting, etc. JavaScript code used on the pages. I\'m not sure what the exact logic of what it does, but end of the day, I _did not want_ Docusaurus manipulating the JS generated by the WASM build process.\\n\\nAdmittedly this is a bit of laziness on my part for not really understanding what Docusaurus does and how best to circumvent it.\\n\\n#### Workaround\\n\\nI worked around the reload problems and script mangling with a custom MDX Component in Docusaurus that:\\n\\n1. Directly injects a `<script>` element so Docusaurus can\'t modify what it does\\n2. Uses a hacky exception handler to reload the page if the WASM seems to fail (usually what happens on the second visit to the page without an intermittent reload)\\n3. Sets a retry limit in case the logic for (2) is not right in all cases (because this is a hacky workaround, not robust code so precautions against an infinite loop are important!)\\n\\n```js\\nexport function CanvasWASM({\\n    id,\\n    module,\\n    width,\\n    height,\\n    style,\\n}: {\\n    id: string,\\n    module: string,\\n    width: number,\\n    height: number,\\n    style?: React.CSSProperties,\\n}) {\\n    React.useEffect(() => {\\n        // We create a a DOM element since Docusaurus ends up renaming /\\n        // changing the JS file to load the WASM which breaks the import\\n        // in production.  This is pretty hacky but it works (for now).\\n        const script = document.createElement(\'script\');\\n        script.type = \'module\';\\n        script.text = `            \\nlet key = \'wasm-retry-count-${module}-${id}\';\\nlet success = setTimeout(function() {\\n    localStorage.setItem(key, \\"0\\");\\n}, 3500);\\n\\nconst go = async () => {\\n    try {       \\n        let mod = await import(\'${module}\');\\n        await mod.default();\\n        await mod.start(\'${id}\');\\n        localStorage.setItem(key, \\"0\\");\\n    } catch (e) {     \\n        if (e.message == \\"unreachable\\") {        \\n            clearTimeout(success);\\n            let value = parseInt(localStorage.getItem(key) || \\"0\\", 10);\\n            if (value < 10) {                \\n                console.log(\\"WASM error, retry attempt: \\", value);\\n                setTimeout(function() {\\n                    localStorage.setItem(key, (value + 1).toString());\\n                    window.location.reload();\\n                }, 20 + 100 * value);\\n            } else {\\n                throw e;\\n            }\\n        }\\n    }\\n};\\ngo();\\n            `.trim();\\n        document.body.appendChild(script);\\n    }, []);\\n\\n    return <canvas id={id} width={width} height={height} style={style}></canvas>;\\n}\\n```\\n\\n### An aside of GitHub Large File Storage (LFS)\\n\\n_In case anyone on the internet runs into this and stumbles upon this page..._\\n\\nI also wasted quite a bit of time on this problem:\\n\\n1. I publish this site using GitHub Pages\\n2. I generally set a `.gitattributes` file in all my repos to store generated files using git LFS\\n3. I have an entry for `*.wasm` to store those in LFS\\n4. **GitHub Pages doesn\'t use LFS when serving the files**\\n\\nThis meant my code was working locally but when I was trying to load the WASM files on the published site, _the LFS \\"pointer\\" text file was being served rather than the binary WASM file itself_. It took me a while to figure this out. Ultimately the fix was to remove the `.gitattributes` from the GitHub Pages repo so LFS is _not_ used on the published site. (Aside: this might be a good reason to consider hosting this site via another platform, but I\'ll leave that for another day!)"},{"id":"/2024/09/04/index","metadata":{"permalink":"/blog/2024/09/04/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-09-04/index.md","source":"@site/blog/2024-09-04/index.md","title":"Voxel shader","description":"Rewrote the WGPU render pass for rendering the voxels to use an instance buffer than generates 36 vertices per instance (i.e. vertices for the 6 \\\\* 2 = 12 triangles of a voxel).","date":"2024-09-04T00:00:00.000Z","tags":[{"inline":true,"label":"voxels","permalink":"/blog/tags/voxels"},{"inline":true,"label":"wpgu","permalink":"/blog/tags/wpgu"},{"inline":true,"label":"render-pass","permalink":"/blog/tags/render-pass"}],"readingTime":2.57,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["voxels","wpgu","render-pass"]},"unlisted":false,"prevItem":{"title":"Bevy WASM rendering","permalink":"/blog/2024/10/28/2024-10-28/"},"nextItem":{"title":"Rain","permalink":"/blog/2024/09/03/index"}},"content":"Rewrote the WGPU render pass for rendering the voxels to use an instance buffer than generates 36 vertices per instance (i.e. vertices for the 6 \\\\* 2 = 12 triangles of a voxel).\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-09-04+18-02-37.mp4\\"/>\\n\\nI\'m not sure if this is going to be the right approach, but I wanted to at least experiment with it.\\n\\n:::warning Not so fast!\\n\\n**Update:** naively swapping the instance-based rendering in for the more traditional triangle renderer was MUCH slower. I\'m not confident this is going to be a better rendering method.\\n\\n:::\\n\\n### Rambling a bit on ways to render the voxels\\n\\nThe approach used in the above video is fairly naive. Each voxel is given a `vec3<f32>` position and `vec3<f32>` color. The buffer itself has one entry for each filled voxel. It is instanced 36 times to generate the full cube for each voxel. So 36 instances and and 6 x 32 = 192 bits = 24 bytes per instance.\\n\\nGiven that each voxel is a cube, this could be optimized to figure out the view direction and draw only the 3 faces that are oriented towards the camera. Thus we could reduce the instancing down to 3 quads = 12 vertices. It should be easy to do this as the shader can read the left or right face, top or bottom, and front or back: it can know which for each of those three by simply looking if the x, y, z of the view direction is positive or negative.\\n\\nChunks are currently 32x32x8. Or 2^5 x 2^5 x 2^3. That means each chunk needs only 13-bits to storage the location of a voxel within a chunk. I could send each \\"instances\\" as 13-bits plus a vec3 translation for the whole chunk. Let\'s round that up to a u16 per voxel. I could make the chunks 16x16x8 and limit each chunk to a map of 128 values thus compacting both the position and color into a u16. For to leave room for flexibility, I\'ll assume a u32 could hold all the per-voxel info in a 32x32x8 chunk. That\'s 32k per chunk. Given 512MB reserved for chunks, that\'s 16k chunks. That\'s 128x128 horizontally assuming a depth of 1. If we assume we need an average chunk depth of 4 (which seems pretty agressive), that\'s 64x64 chunks. If we assume we load chunks equally in front and behind the player, that\'s a view distance of 32 chunks. Each chunk has 32 voxels and there are 4 voxels per meter, there\'s a view distance of 256 meters -- roughly a quarter of a kilometer.\\n\\nThere\'s also a question of sending chunks where only the visible voxels are sent. This would be more efficient on the surface, as it saves a lot of space for mostly empty chunks. However, it makes modifications more difficult: the WGPU buffers are not resizable and there\'s not a fixed position-to-index mapping function. It might be nice to support both: optimize a chunk that hasn\'t been modified for a while and leave recently modified chunks as the full voxel space."},{"id":"/2024/09/03/index","metadata":{"permalink":"/blog/2024/09/03/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-09-03/index.md","source":"@site/blog/2024-09-03/index.md","title":"Rain","description":"Updated the particle system to look more like rain (which was the original goal):","date":"2024-09-03T00:00:00.000Z","tags":[{"inline":true,"label":"rain","permalink":"/blog/tags/rain"},{"inline":true,"label":"particles","permalink":"/blog/tags/particles"},{"inline":true,"label":"vertex-buffers","permalink":"/blog/tags/vertex-buffers"}],"readingTime":0.35,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["rain","particles","vertex-buffers"]},"unlisted":false,"prevItem":{"title":"Voxel shader","permalink":"/blog/2024/09/04/index"},"nextItem":{"title":"Particles","permalink":"/blog/2024/09/02/index"}},"content":"Updated the particle system to look more like rain (which was the original goal):\\n\\n#### Prototype scene\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-09-03+10-34-59.mp4\\"/>\\n\\n#### With terrain\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-09-03+10-47-50.mp4\\"/>\\n\\n#### Client \\"cards\\"\\n\\nThe rain is added by \\"playing\\" a card for rain. There are only two supported cards so far!\\n\\n<img src={require(\\"./image.png\\").default} style={{ border: \'solid 1px #CCC\',display:\'block\', margin: \\"0 auto\\", borderRadius: 8, boxShadow: \\"2px 2px 4px rgba(0,0,0,.2)\\"}}/>"},{"id":"/2024/09/02/index","metadata":{"permalink":"/blog/2024/09/02/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-09-02/index.md","source":"@site/blog/2024-09-02/index.md","title":"Particles","description":"Got a \\"particle system\\" working. This is a simple point grid being mapped to a sine wave.","date":"2024-09-02T00:00:00.000Z","tags":[{"inline":true,"label":"particles","permalink":"/blog/tags/particles"},{"inline":true,"label":"wgpu","permalink":"/blog/tags/wgpu"},{"inline":true,"label":"particle-systems","permalink":"/blog/tags/particle-systems"},{"inline":true,"label":"actors","permalink":"/blog/tags/actors"},{"inline":true,"label":"snowfall","permalink":"/blog/tags/snowfall"}],"readingTime":0.265,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["particles","wgpu","particle-systems","actors","snowfall"]},"unlisted":false,"prevItem":{"title":"Rain","permalink":"/blog/2024/09/03/index"},"nextItem":{"title":"Point rendering","permalink":"/blog/2024/09/01/index"}},"content":"Got a \\"particle system\\" working. This is a simple point grid being mapped to a sine wave.\\n\\nThe core of the work was figuring out dynamic WGPU vertex updates and reworking some of the overly simple parts of the Snowfall architecture to account for changing geometry.\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-09-02+17-16-36.mp4\\" />"},{"id":"/2024/09/01/index","metadata":{"permalink":"/blog/2024/09/01/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-09-01/index.md","source":"@site/blog/2024-09-01/index.md","title":"Point rendering","description":"I\'ve started working on adding rain to Snowscape. This will require improving a lot of the very, very fledgling engine internals.","date":"2024-09-01T00:00:00.000Z","tags":[],"readingTime":4.085,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Particles","permalink":"/blog/2024/09/02/index"},"nextItem":{"title":"Minimal React Frontend","permalink":"/blog/2024/08/31/p1"}},"content":"I\'ve started working on [adding rain](/docs/snowfall/roadmap/prds/rain-card) to Snowscape. This will require improving a lot of the very, very fledgling engine internals.\\n\\n## WGPU isn\'t that easy\\n\\nI\'m liking WGPU but it rarely seems that things Just Work (tm)...\\n\\nAdding point rendering - just drawing individual pixels - was trivial. Basically duplicate all the line rendering code and make a few minor tweaks to the primitive type data definitions (e.g. `PointList`, not `LineList`).\\n\\nSo on to finding the equivalent of `glPointSize`. And...there is no equivalent. This [webgpufundamentals post](https://webgpufundamentals.org/webgpu/lessons/webgpu-points.html) however was very helpful. TL;DR: use instancing to render the points so each point is generates a quad. This was very interesting since I hadn\'t used instancing before in almost any context and also had been wondering what the WGPU equivalent of geometry shaders might be.\\n\\n#### First try...\\n\\nFor debugging, I tried rendering a grid of points as quads using `LineList` primitives but that didn\'t work:\\n\\n![alt text](image.png)\\n\\n#### Vertex index vs. instance index\\n\\nTurned out I had my index and vertex buffers backwards. The [VertexStepMode](https://docs.rs/wgpu/latest/wgpu/enum.VertexStepMode.html) docs clued me into the error: in that parlance, I had my \\"rows\\" and \\"columns\\" transposed so that I was generating the primitives based on instance index rather than vertex index.\\n\\nOnce I figured that out, the points rendered as quads (with debugging colors on each generated vertex):\\n\\n![alt text](image-1.png)\\n\\n## The working code\\n\\n**Define the `vs_main` input as an `Instance`, not a `Vertex`.** Yes, the shader generates vertices, so it is a vertex shader still, but the input is the instance information. The additional information we need is the `builtin(vertex_index)` to know _which_ vertex we\'re generating for the Instance. I confused myself by thinking of the `vs_main` input still being a `Vertex` originally.\\n\\n```wgsl\\nstruct Globals {\\n    view            : mat4x4<f32>,\\n    proj            : mat4x4<f32>,\\n    view_proj       : mat4x4<f32>,\\n    camera_position : vec3<f32>,\\n};\\n\\n@group(0) @binding(0)\\nvar<uniform> globals : Globals;\\n\\nstruct Locals {\\n};\\n@group(1) @binding(0)\\nvar<uniform> locals: Locals;\\n\\n\\nstruct Instance {\\n    @location(0) position : vec3<f32>,\\n    @location(1) color    : vec3<f32>,\\n};\\n\\nstruct Fragment {\\n    @builtin(position) clip_position : vec4<f32>,\\n    @location(0)       color         : vec3<f32>,\\n};\\n\\n// This is called in with an \\"instance\\" step mode.\\n//\\n// There are N invocations of the vertex shader, one for each vertex\\n// of the instance.  In this case, we\'re rendering a quad as two triangles\\n// so N=6. (The render pipeline is set up to TriangeList, so a triangle\\n// is generated for each consecutive 3 vertex_index values).\\n//\\n// We use the Instance position to generate the center world coordinate,\\n// then generate 6 vertices in NDC space for the quad.\\n//\\n@vertex\\nfn vs_main(\\n    instance : Instance,\\n    @builtin(vertex_index) vertexIndex: u32,\\n) -> Fragment {\\n\\n    var vertices = array(\\n          vec2f(-1, -1),\\n          vec2f( 1, -1),\\n          vec2f(-1,  1),\\n\\n          vec2f( 1,  1),\\n          vec2f( 1, -1),\\n          vec2f(-1,  1),\\n    );\\n    var vertex_pos = vertices[vertexIndex];\\n    # TODO: remove hard-coded point size conversion\\n    var vertex_ndc = vec4<f32>(vertex_pos * 100.0/400.0, 0.0, 0.0);\\n\\n    // Eye coordinates\\n    var ec = globals.view * vec4<f32>(instance.position, 1.0);\\n\\n    var frag: Fragment;\\n    frag.color = instance.color;\\n    frag.clip_position = globals.proj * ec + vertex_ndc;\\n    return frag;\\n}\\n\\n@fragment\\nfn fs_main(frag : Fragment) -> @location(0) vec4<f32> {\\n    var c = frag.color;\\n    return vec4<f32>(c, 1.0);\\n}\\n\\n```\\n\\n**The shader is tightly coupled to the vertex layout and draw call**. The shader below assumes it will be called with a count of six and exactly six for each instance. The `step_mode` must also be set correctly. This doesn\'t feel very \\"reuse friendly\\" but makes sense that layouts and shaders would be so tightly coupled.\\n\\n```rust\\n    // Adds the commands to render the buffer to the queue\\n    //\\n    pub fn activate(&self, render_pass: &mut wgpu::RenderPass) {\\n        let bytes = self.instance_buffer.size() as u32;\\n        let size = std::mem::size_of::<PointInstance>() as u32;\\n        let count = bytes / size;\\n\\n        // NOTE: the method naming is distracting since we\'re setting\\n        // the *instance buffer* here, not a vertex buffer.\\n        render_pass.set_vertex_buffer(0, self.instance_buffer.slice(..));\\n\\n        // The shader is hard-coded to generate 6 vertices per instance\\n        render_pass.draw(0..6, 0..count);\\n    }\\n```\\n\\n**The WGPU naming can be misleading for those new to instancing.** It\'s also rather distracting that \\"logically\\" the vertex format is instance data, but the WGPU naming conventions for the structs and methods all refer to this as a vertex buffer. I\'m sure this is appropriate naming looking a the holistic design of WGPU, but this was quite confusing in figuring out how instancing works for the first time!\\n\\n```rust\\nimpl PointInstance {\\n    pub fn desc() -> wgpu::VertexBufferLayout<\'static> {\\n        wgpu::VertexBufferLayout {\\n            array_stride: std::mem::size_of::<PointInstance>() as wgpu::BufferAddress,\\n            step_mode: wgpu::VertexStepMode::Instance, // <-- THIS\\n            attributes: &[\\n                wgpu::VertexAttribute {\\n                    offset: 0,\\n                    shader_location: 0,\\n                    format: wgpu::VertexFormat::Float32x3,\\n                },\\n                wgpu::VertexAttribute {\\n                    offset: std::mem::size_of::<[f32; 3]>() as wgpu::BufferAddress,\\n                    shader_location: 1,\\n                    format: wgpu::VertexFormat::Float32x3,\\n                },\\n            ],\\n        }\\n    }\\n}\\n```\\n\\nThe shader is also tightly coupled to the `RenderPass` as that needs its primitive topology to be set to `TriangeList`.\\n\\n```rust\\nprimitive: wgpu::PrimitiveState {\\n    cull_mode: None,\\n    topology: wgpu::PrimitiveTopology::TriangleList,  // <-- THIS\\n    strip_index_format: None,\\n    front_face: wgpu::FrontFace::Ccw,\\n    polygon_mode: wgpu::PolygonMode::Fill,\\n    unclipped_depth: false,\\n    conservative: false,\\n},\\n```"},{"id":"/2024/08/31/p1","metadata":{"permalink":"/blog/2024/08/31/p1","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-31-p1/index.md","source":"@site/blog/2024-08-31-p1/index.md","title":"Minimal React Frontend","description":"To accelerate being UI development and debugging of Snowscape, I\'m building a web-based front-end that can connect to the engine. I\'m familiar with React and TypeScript, so being able to use the browser development environment will speed things along (versus trying to learn egui or another Rust-based framework at this point in development).","date":"2024-08-31T00:00:00.000Z","tags":[{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"frontend","permalink":"/blog/tags/frontend"},{"inline":true,"label":"build","permalink":"/blog/tags/build"},{"inline":true,"label":"typescript","permalink":"/blog/tags/typescript"},{"inline":true,"label":"make","permalink":"/blog/tags/make"},{"inline":true,"label":"makefile","permalink":"/blog/tags/makefile"}],"readingTime":4.45,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["react","frontend","build","typescript","make","makefile"]},"unlisted":false,"prevItem":{"title":"Point rendering","permalink":"/blog/2024/09/01/index"},"nextItem":{"title":"Worth reading","permalink":"/blog/2024/08/31/p2"}},"content":"To accelerate being UI development and debugging of Snowscape, I\'m building a web-based front-end that can connect to the engine. I\'m familiar with React and TypeScript, so being able to use the browser development environment will speed things along (versus trying to learn egui or another Rust-based framework at this point in development).\\n\\nJavaScript tooling drives me a bit bonkers so here\'s a quick write-up on my \\"minimal\\" setup to get a front-end going (i.e. for simple, non-production purposes). Given the rate of change in the JavaScript ecosystem, who knows how long this post will be useful or relevant for!\\n\\n### The files\\n\\nThe \\"minimal\\" files needed here are:\\n\\n```\\nsrc/\\n    app.tsx\\n    main.tsx\\n    index.html\\n    style.css\\nscripts/\\n    open-browser.js\\n\\n.gitignore\\npackage.json\\nMakefile\\n```\\n\\n### The Makefile (Makefile)\\n\\nI like Makefiles because I know `make build` is going to build my project and I don\'t have to worry about whether the project is using `npm`, `npx`, `tsc`, `esbuild`, `cargo`, etc. This is great for large complex monorepos using multiple languages as well as for coming back to old personal projects where I\'ve long since forgotten all the details of how I build it.\\n\\nI\'m a big fan of language agnostic command-runners and Make, while hardly perfect, is ubiquitously available -- which is a good fit for a command runner you\'re using to avoid having to remmeber specialized tools.\\n\\n```Makefile\\n.PHONY: ensure build run dev\\n\\nensure:\\n\\tnpm i\\n\\nbuild: ensure\\n\\tmkdir -p dist/static\\n\\tcp src/index.html dist\\n\\tcp src/style.css dist\\n\\tnpx esbuild \\\\\\n\\t\\t--preserve-symlinks \\\\\\n\\t\\t--loader:.js=jsx \\\\\\n\\t\\t--loader:.md=text \\\\\\n\\t\\t--loader:.yaml=text \\\\\\n\\t\\t--loader:.txt=text \\\\\\n\\t\\t--sourcemap \\\\\\n\\t\\t--bundle src/main.tsx \\\\\\n\\t\\t--outfile=dist/main.bundle.js\\n\\nrun: build\\n\\t(sleep 2 && node scripts/open-browser.js) &\\n\\tnpx http-server -c-1 dist\\n\\ndev:\\n\\t$(MAKE) run &\\n\\tnpx nodemon \\\\\\n\\t\\t--watch src \\\\\\n\\t\\t--ext ts,tsx,html,css,yaml,yml \\\\\\n\\t\\t--exec \\"make build || exit 1\\"\\n```\\n\\n### Tools & dependencies (package.json)\\n\\nThe above requires some tools, so let\'s look at the `package.json`:\\n\\n```js\\n{\\n    \\"devDependencies\\": {\\n        \\"@types/react\\": \\"^18.3.5\\",\\n        \\"esbuild\\": \\"^0.23.1\\",\\n        \\"http-server\\": \\"^14.1.1\\",\\n        \\"nodemon\\": \\"^3.1.4\\",\\n        \\"react-dev-utils\\": \\"^12.0.1\\"\\n    },\\n    \\"dependencies\\": {\\n        \\"react\\": \\"^18.3.1\\",\\n        \\"react-dom\\": \\"^18.3.1\\"\\n    }\\n}\\n```\\n\\n#### open-browser.js\\n\\nAnd we have one super simple script `scripts/open-browswer.js` for opening a browswer tab when the client is launched. It\'s basically just a wrapper to call a function in an external package:\\n\\n```js\\nconst openBrowser = require(\'react-dev-utils/openBrowser\');\\nopenBrowser(\'http://localhost:8080\');\\n```\\n\\n### Files to keep out of git (.gitignore)\\n\\nAnd let\'s not forget about making a `.gitignore` so we don\'t accidentally commit built files to the repo that we don\'t want there:\\n\\n```\\n/node_modules/\\n/dist/\\n```\\n\\n### Boilerplate minimal HTML (index.html)\\n\\nWe need an `index.html` to host the page:\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n    <head>\\n        <meta charset=\\"utf-8\\" />\\n        <meta http-equiv=\\"cache-control\\" content=\\"no-cache\\" />\\n        <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\"></meta>\\n        <link href=\\"style.css\\" rel=\\"stylesheet\\" />\\n        <title></title>\\n    </head>\\n    <body>\\n        <div id=\\"root\\"></div>\\n        <script src=\\"main.bundle.js\\" type=\\"application/javascript\\"><\/script>\\n    </body>\\n</html>\\n```\\n\\n### Boilerplate CSS (style.css)\\n\\nI generally use inline CSS for small projects, but it\'s nice to have a single CSS for global settings, normalization, etc.\\n\\n```css\\nbody {\\n    margin: 0;\\n    padding: 0;\\n\\n    font-family: monospace;\\n}\\n```\\n\\n### React bootstrapping (main.tsx)\\n\\nI like the convention of having a `main()` function that calls a `Main` component and, between those two, all the foundational \\"plumbing\\" of a React app is handled. In particular, for a simple development/debugging client like it adds very basic, minimal \\"hot reloading\\" that polls for changes to the underlying script bundle (no complicated dev servers: just a simple polling loop with a handful of lines of code).\\n\\n```tsx\\nimport React, { JSX } from \'react\';\\nimport ReactDOM from \'react-dom/client\';\\nimport { App } from \'./app\';\\n\\nfunction Main(): JSX.Element {\\n    return <App />;\\n}\\n\\nasync function main() {\\n    console.log(\'--- snowscape client main ----\');\\n    pollForReload(\'/main.bundle.js\');\\n    pollForReload(\'/style.css\');\\n\\n    const element = document.getElementById(\'root\')!;\\n    const root = ReactDOM.createRoot(element);\\n    root.render(<Main />);\\n}\\n\\nmain();\\n\\nfunction pollForReload(url) {\\n    let previous: string | null = null;\\n    const poll = async () => {\\n        const resp = await fetch(url);\\n        const text = await resp.text();\\n        if (previous === null) {\\n            previous = text;\\n        } else if (previous !== text) {\\n            window.location.reload();\\n        }\\n        setTimeout(poll, 800 + Math.random() * 800);\\n    };\\n    setTimeout(poll, 250);\\n}\\n```\\n\\n### The actual app (App.tsx)\\n\\nThe plumbing out of the way, we now have a place to start developing the app in a file that free of the any of the bootstrapping logic:\\n\\n```tsx\\nimport React, { JSX } from \'react\';\\n\\nexport function App(): JSX.Element {\\n    return (\\n        <div>\\n            <h1>Hello App</h1>\\n        </div>\\n    );\\n}\\n```\\n\\n### Where\'s all the other stuff?\\n\\nWhat about `eslint`, hot reloading dev server that can load individual components, tailwind CSS integration, API generation, deployment scripts, etc. etc.?\\n\\nI\'m very wary of the \\"not built here\\" syndrome that leads to developers (including myself) building things themselves that have already been built by others in high-quality fashion. However, over the years, too many times JavaScript build systems have \\"locked\\" my projects into a certain way of developing that (1) makes upgrades to new libraries hard, (2) doesn\'t work with other libraries / tools, (3) breaks mysteriously after not being used for 6+ months, (4) etc. As such, I tend to try to keep JavaScript build systems pretty minimal and \\"unabstracted\\" so it\'s easier to debug when there\'s a build issue. That said, the above is \\"good enough\\" for most of the simple one-off apps I experiment with but certainly not the best and probably not what is desirable for a full, production web app being developed by a team!"},{"id":"/2024/08/31/p2","metadata":{"permalink":"/blog/2024/08/31/p2","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-31-p2/index.md","source":"@site/blog/2024-08-31-p2/index.md","title":"Worth reading","description":"Mostly about physics simulation in games...","date":"2024-08-31T00:00:00.000Z","tags":[{"inline":true,"label":"worth-reading","permalink":"/blog/tags/worth-reading"},{"inline":true,"label":"physics","permalink":"/blog/tags/physics"},{"inline":true,"label":"points","permalink":"/blog/tags/points"}],"readingTime":0.15,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["worth-reading","physics","points"]},"unlisted":false,"prevItem":{"title":"Minimal React Frontend","permalink":"/blog/2024/08/31/p1"},"nextItem":{"title":"Render pipeline improvements","permalink":"/blog/2024/08/23/index"}},"content":"Mostly about physics simulation in games...\\n\\n-   https://www.cs.cmu.edu/~baraff/sigcourse/index.html\\n-   https://gafferongames.com/post/integration_basics/\\n-   https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics - good article in itself, but also has some very useful links\\n\\nPoint rendering in WGPU...\\n\\n-   https://webgpufundamentals.org/webgpu/lessons/webgpu-points.html"},{"id":"/2024/08/23/index","metadata":{"permalink":"/blog/2024/08/23/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-23/index.md","source":"@site/blog/2024-08-23/index.md","title":"Render pipeline improvements","description":"-   Cleaned up the line rendering a bit","date":"2024-08-23T00:00:00.000Z","tags":[],"readingTime":0.255,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Worth reading","permalink":"/blog/2024/08/31/p2"},"nextItem":{"title":"Render passes","permalink":"/blog/2024/08/22/index"}},"content":"-   Cleaned up the line rendering a bit\\n-   Added a \\"built-in\\" primitve for an XY-grid\\n-   Modified the instance to allow it to stay locked to the camera position\\n-   Allow for pass filters so instances go to the right pass / shader\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-23+10-27-26.mp4\\" />"},{"id":"/2024/08/22/index","metadata":{"permalink":"/blog/2024/08/22/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-22/index.md","source":"@site/blog/2024-08-22/index.md","title":"Render passes","description":"What\'s exciting about the below image?","date":"2024-08-22T00:00:00.000Z","tags":[{"inline":true,"label":"wgpu","permalink":"/blog/tags/wgpu"},{"inline":true,"label":"render-passes","permalink":"/blog/tags/render-passes"},{"inline":true,"label":"debug","permalink":"/blog/tags/debug"},{"inline":true,"label":"lines","permalink":"/blog/tags/lines"},{"inline":true,"label":"shaders","permalink":"/blog/tags/shaders"},{"inline":true,"label":"wgsl","permalink":"/blog/tags/wgsl"},{"inline":true,"label":"http","permalink":"/blog/tags/http"}],"readingTime":0.5,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["wgpu","render-passes","debug","lines","shaders","wgsl","http"]},"unlisted":false,"prevItem":{"title":"Render pipeline improvements","permalink":"/blog/2024/08/23/index"},"nextItem":{"title":"WIP: voxel chunking","permalink":"/blog/2024/08/21/index"}},"content":"What\'s exciting about the below image?\\n\\nIt is rendering **lines**.\\n\\n![alt text](image.png)\\n\\nMostly internal work to refactor code and conceptual work to understand the various components of the WGPU architecture, but the engine code now supports rendering lines. This involved setting up a separate shader, render pass, line geometry buffer, and a few other things.\\n\\nNot too exciting, but progress!\\n\\n#### Also: an engine debug view\\n\\nAlso in the not-that-exciting category, I added a debug web view. The engine starts a small HTTP server that serves up basic data about the engine state. There\'s not much there yet!\\n\\n![alt text](image-1.png)"},{"id":"/2024/08/21/index","metadata":{"permalink":"/blog/2024/08/21/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-21/index.md","source":"@site/blog/2024-08-21/index.md","title":"WIP: voxel chunking","description":"A very work-in-progress implementation of voxel chunking and generation.","date":"2024-08-21T00:00:00.000Z","tags":[],"readingTime":3.615,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Render passes","permalink":"/blog/2024/08/22/index"},"nextItem":{"title":"Plugins as dylibs","permalink":"/blog/2024/08/20/index"}},"content":"A very work-in-progress implementation of voxel chunking and generation.\\n\\n#### Update 3: \\"Optimizations\\"\\n\\nAfter thinking about what I need to optimzie for a bit, I realized I was still running everything as debug build! :man_facepalming:\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+14-58-34.mp4\\"/>\\n\\n#### Update 2: slow, but headed in the right direction\\n\\n<video loop controls muted=\\"true\\" autoplay=\\"true\\" src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+13-19-32.mp4\\"  />\\n\\n#### Update with more progress\\n\\n<video src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+12-10-49.mp4\\" loop controls muted=\\"true\\" autoplay=\\"true\\" />\\n\\n#### Pseudo-code\\n\\n```\\nCache\\n    entries : Map<Cell position, Entry>\\n\\nEntry\\n    timestamp\\n    instance_id\\n\\nupdate_cells:\\n    compute a NxNxM bounds around the camera\\n    transform the corners to cell coordinates\\n        cells are 32x32x8\\n\\n    scan each cell in the bounds\\n        if cache[cell coords] is empty\\n            add a new entry\\n        entry.timestamp = now\\n\\n    for each cache entry\\n        if entry.timestamp > AGE\\n            remove instance.id from scene\\n            drop entry\\n        else if entry has no model instance\\n            instance = call generator(cell bounds)\\n            entry.id = instance.id\\n            add instance to scene\\n```\\n\\n#### Work-in-progress\\n\\nThe below gets the basic pseudo-code going, which was the goal. It has a number of issues, which were intentionally deferred to be addressed later:\\n\\n-   [ ] Hook in a real terrain generator function\\n-   [ ] Improve the Potentially Visible Set (PVS) code - the fixed bounds around the camera seems a bit too brute force\\n-   [ ] Cell cache\\n    -   [ ] Address stuttering - rhe load/discard adds and removes many tiles at once. Seems like it would benefit from spreading out the load and/or somehow being smarter about the load/discard process.\\n-   [ ] General performance - does a lot of work already and seems slow. Need to look into what kind of unnecessary work it is doing. Do that research before deciding what code changes are needed.\\n-   [ ] The generator simply clones a fixed tile instance. It\'s not a \\"real\\" generator\\n-   [ ] The load/discard of new tiles has a lot of stutter as many tiles get added / removed at once\\n-   [ ] The potential visible set bounds are intentionally small for debugging\\n-   [ ] General performance: this does a lot of work, which doesn\'t seem scalable without refinement\\n\\n<video style={{ width: \'100%\' }} src=\\"https://f004.backblazeb2.com/file/raiment-studios-media/2024/2024-08-21+09-21-58.mov\\" controls=\\"controls\\" muted=\\"muted\\" class=\\"d-block rounded-bottom-2 border-top width-fit\\"></video>\\n\\n#### End-to-end functionality first\\n\\nA bit about how I approach new work where I personally don\'t know exactly what needs to be done.\\n\\nNote that step (2c) is (surprisingly?) often the easiest step to ignore yet the most beneficial to do well in terms of it\'s impact of understanding the problem space and implementating something both quickly but also future-friendly.\\n\\n```\\n1. Define the result\\n\\n2. Get it working\\n    a. Define the high-level approach\\n    b. Implement a rough end-to-end pipeline\\n    c. Proxy as many details as possible (i.e. use the simplest\\n       implementation I can that still is representative of what\\n       I eventually want)\\n\\n3. Rinse-and-repeat step 2 until it works\\n\\n4. Make it better\\n    a. Replace proxies with real implementations\\n    b. Fill in details\\n\\n5. Scope to \\"good enough\\"\\n    a. Repeat 4 until it feels \\"complete\\" even if it\'s not what I\\n       fully wanted in 1\\n    b. Recognize\\n\\n5. Code clean-up\\n    a. Remember I won\'t remember what I had been thinking even a\\n       week later, so code comments, naming, and general clean-up\\n       are worth it\\n\\n6. Write-up\\n    a. Write a light summary of what I did. This highlights what I may\\n       have missed especially around (1), (2a), and (5)\\n    b. Write out the next todos to make it possible to pick up where\\n       I left off later\\n```\\n\\nIn this particular case, looking at step (2c) the keys to getting something going were:\\n\\n1.  Cloning a fixed instance rather than using a real, position dependent terrain generator\\n2.  Making that fixed instance something very simple\\n3.  Making the potentially visible set logic very simple (just a fixed bounds)\\n4.  Ignoring performance until I got it functionally working\\n\\n#### Performance fix\\n\\nFigured out part of the performance issues:\\n\\n1. I had incorrectly assumed dropping stale tiles would be fast; it wasn\'t\\n2. Dropped instances could be anywhere in the instance list\\n3. The re-sync code was written such that any mismatch implicitly invalidated everything after it in the list\\n\\nThe fix was to hash the existing instance IDs and check for against that unordered table rather than continuing the very simple prior logic which assumed indicies always aligned."},{"id":"/2024/08/20/index","metadata":{"permalink":"/blog/2024/08/20/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-20/index.md","source":"@site/blog/2024-08-20/index.md","title":"Plugins as dylibs","description":"Nothing new in the image below! Under the hood though, the code changed...","date":"2024-08-20T00:00:00.000Z","tags":[],"readingTime":1.635,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"WIP: voxel chunking","permalink":"/blog/2024/08/21/index"},"nextItem":{"title":"Terrain generator","permalink":"/blog/2024/08/19/index"}},"content":"Nothing new in the image below! Under the hood though, the code changed...\\n\\n<div style={{ display: \'flex\', flexDirection: \'row\', gap: 16 }}>\\n<div style={{ flex: \'1 0 0\', borderRadius: 4, border: \'1px solid #CCC\', padding: 16 }}>\\n**From**\\n\\nBuild and run Rust plugins as processes.\\n\\nPass parameters in as a JSON string to the command-line.\\nReceive output as YAML on stdout.\\n\\nSimple but not the most efficient encoding and limited to one fixed output on stdout.\\n\\n</div>\\n<div style={{ fontSize: \'200%\', alignSelf: \'center\'}}>\u27f6</div>\\n<div style={{ flex: \'1 0 0\', borderRadius: 4, border: \'1px solid #CCC\', padding: 16 }}>\\n**To**\\n\\nBuild and run Rust plugins as dynamic libraries.\\n\\nPass parameters via JSON still, but plugin functions return structs as `bitcode`-encoded byte arrays.\\n\\nStill fairly simple, bitcode seems (not that surprisingly) more efficient. The dynamic library can have multiple entry points for more flexibility.\\n\\n</div>\\n</div>\\n\\n![alt text](image.png)\\n\\nIt\'s somewhat interesting to note this is my third \\"try\\" at plugins already. Maybe I should plan more in advance? Maybe this is part of the learning experience?\\n\\n**\\\\#3 Rust dynamic libraries:** once I had a better understanding of what I wanted to do, this seems like a more natural fit. Leaves room for more generic plugins, including ones that stay in memory. May want a process/\\"service\\"-based mode for added decoupling in the future, but for now, this is a very easy approach for single-file, run-once plugins.\\n\\n**\\\\#2 Rust processes**: moved to this to get the type checking. As I\'m still learning Rust, more or less dove straight into hacking this together just to get something to work. Stuck with the JSON/YAML exchange formats since it let me postpone worrying about them.\\n\\n**\\\\#1 Deno-based node plug-ins**: had some old JS code for generating terrains. Thought it might be nice to allow the imprecision of JS and just rely on JSON/YAML formats for data exchange. Moved on what I quickly realized I wanted the type-checking of Rust, including on the interchange formats."},{"id":"/2024/08/19/index","metadata":{"permalink":"/blog/2024/08/19/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-19/index.md","source":"@site/blog/2024-08-19/index.md","title":"Terrain generator","description":"Added the ability to write Rust \\"scripts\\" (basically crates that the engine will run to get model output from) and added a voxel terrain with some basic procedural noise. I think of it as a \\"script\\" since it uses a blanket important use scriptlib::*; which brings in a lot of utilities to keep the code itself concise.","date":"2024-08-19T00:00:00.000Z","tags":[{"inline":true,"label":"terrain","permalink":"/blog/tags/terrain"},{"inline":true,"label":"scripting","permalink":"/blog/tags/scripting"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"}],"readingTime":0.4,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["terrain","scripting","rust"]},"unlisted":false,"prevItem":{"title":"Plugins as dylibs","permalink":"/blog/2024/08/20/index"},"nextItem":{"title":"Hot reloading architecture","permalink":"/blog/2024/08/18/p1"}},"content":"Added the ability to write Rust \\"scripts\\" (basically crates that the engine will run to get model output from) and added a voxel terrain with some basic procedural noise. I think of it as a \\"script\\" since it uses a blanket important `use scriptlib::*;` which brings in a lot of utilities to keep the code itself concise.\\n\\nAlso switched the WGPU to prefer linear RGB color until I progress a bit further and want to handle sRGB correctly.\\n\\n![alt text](image.png)"},{"id":"/2024/08/18/p1","metadata":{"permalink":"/blog/2024/08/18/p1","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-18-p1/index.md","source":"@site/blog/2024-08-18-p1/index.md","title":"Hot reloading architecture","description":"_TL;DR: I can now modify my sinscape.js script file and when I do the sine-wave based voxel landscape will automatically refresh in the engine without a restart._","date":"2024-08-18T00:00:00.000Z","tags":[{"inline":true,"label":"hot-reloading","permalink":"/blog/tags/hot-reloading"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"}],"readingTime":7.235,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["hot-reloading","architecture"]},"unlisted":false,"prevItem":{"title":"Terrain generator","permalink":"/blog/2024/08/19/index"},"nextItem":{"title":"Rust generator \\"scripts\\"","permalink":"/blog/2024/08/18/p2"}},"content":"**_TL;DR: I can now modify my `sinscape.js` script file and when I do the sine-wave based voxel landscape will automatically refresh in the engine without a restart._**\\n\\nI wanted to add \\"hot reloading\\" to the engine so that changes to data files are automatically reflected in the running engine. This is one of those small developer-ergonomics changes that, over time, I believe has huge benefits to productivity.\\n\\nThe primary challenge was to architect this such that the engine internals remain clean: i.e.\\n\\n1. Avoid scattering with knowledge of source file to asset mappings throughout the engine\\n2. Avoid introducing complex inter-object references within the engine (makes for a Rust lifetime manageable headache)\\n3. Minimal runtime impact in a release build\\n4. Keep file watching code isolated and independent as it\'s a development feature, not an engine feature\\n\\nI expect to have to revist this as the engine functionality increases and as I learn more about how to use Rust more effectively. \ud83d\ude04\\n\\n:::warning Heads up\\n\\nThis article does not go into full depth on some of changes discussed. **If you\'d like more detail added to any section, let me know!** I wanted to be sure there was an audience for this before going into any more depth.\\n\\n:::\\n\\n### Architecture\\n\\n```mermaid\\ngraph LR\\n    subgraph A[Scene Loading]\\n        DependencyList\\n    end\\n\\n    subgraph B[Engine Actor]\\n        FileWatcher\\n    end\\n\\n    subgraph C[Engine]\\n        DirtyList\\n    end\\n\\n    DependencyList --\x3e FileWatcher --\x3e DirtyList --\x3e HotReload\\n```\\n\\n1. Build a list of files -> asset ids during loading\\n2. Add a dev-only Actor that watches for file change\\n3. Trigger a reload for any assets that have been marked dirty\\n4. Do the reload\\n\\n### Build the dependency graph during scene loading (DependencyList)\\n\\n#### Record the dependencies\\n\\nAs the loader opens files, it maintains a mapping of each file to the list of asset ids that file impacted. Building the \\"graph\\" is simple as long as two rules are followed:\\n\\n1. **Record direct dependencies**: whenever a file is opened, ensure any assets created by that file add any entry mapping that `file -> asset id`\\n2. **Record transitive dependnecies**: whenever an asset relies on data from another asset, copy all the dependencies from the existing asset to the newly created asset.\\n\\n_Example: when loading a `.vox` file, we simply add that file name as a dependency on the model that\'s going to use that vox data._\\n\\n```rust\\ndependency_list.add_model_entry(vox_file.to_str().unwrap(), &desc.header.id);\\n\\nlet vox_data: vox_format::VoxData = vox_format::from_file(vox_file).unwrap();\\n```\\n\\nWe record the dependencies as IDs rather than object references as it\'s far cleaner for managing lifetimes.\\n\\nFor a simple scene, we end up with a list like the following\\n\\n```\\n   1.4 INFO  --- Dependency list ---\\n  [Model]      mmm-house3\\n      data/dist/base/models/mmm-house3/mmm-house3.yaml\\n      data/dist/base/models/mmm-house3/obj_house3.vox\\n  [Model]      sinscape\\n      data/dist/base/generators/sinscape.js\\n      data/dist/base/models/sinscape.yaml\\n  [Model]      unit_cube\\n      data/dist/base/models/unit_cube.yaml\\n  [Scene]      main\\n      data/dist/base/scenes/main.yaml\\n  [Instance]   house-000\\n      data/dist/base/models/mmm-house3/mmm-house3.yaml\\n      data/dist/base/models/mmm-house3/obj_house3.vox\\n      data/dist/base/scenes/main.yaml\\n  [Scene]      main-001\\n      data/dist/base/scenes/main-001.yaml\\n```\\n\\n#### Intrusive tracking\\n\\nThis is an \\"intrusive\\" approach: the bookkeeping of dependency tracking must be inlined directly into the loading logic and cannot be plugged in as an optional feature. This however feels fine as a design choice since the cost of building a mapping table is relatively low and it is conceptually simple.\\n\\nThe loading code _expects_ each asset load to have 1 or more calls to methods such as the below. Thus, we want an interface that makes recording dependencies simple, hard-to-get-wrong, and ideally self-descriptive one-liners.\\n\\n```rust\\nimpl DependencyList {\\n    // ...\\n\\n    // Direct dependencies\\n    pub fn add_scene_entry(&mut self, file_path: &str, id: &str) { ...  }\\n    pub fn add_model_entry(&mut self, file_path: &str, id: &str) { ...  }\\n    pub fn add_instance_entry(&mut self, file_path: &str, id: &str) { ...  }\\n\\n    // Transitive dependencies\\n    pub fn copy_entries(&mut self,\\n        src_type: EntityType, src_id: &str,\\n        dst_type: EntityType, dst_id: &str) { ... }\\n\\n    // ...\\n```\\n\\n#### Design choice: a list not a graph\\n\\nTransitive dependencies _copy_ dependencies which _flattens_ the dependency graph. This makes it a dependency _list_. This is done for simplicity\'s sake, though has a small trade-off (continue reading for more on this).\\n\\n:::note The alternative\\n\\nThe alternative would be to record `asset -> asset` dependencies as well `file -> asset` dependencies. This would add only a little more complexity as the flattening would happen at use, not build, time for the list -- but per the below this didn\'t seem worth doing at this stage. \ud83e\udd37\\n\\n:::\\n\\n#### Design choice: an immutable list after initialization\\n\\nThe architecture builds this list at _initial load_ only. It is treated effectively an immutable/static list after startup.\\n\\n\u2705 The benefit is this is very simple to reason about. The dependency list requires no dynamic update logic.\\n\\n\ud83d\udeab The downside is changes such as file renames or inter-asset dependency modifications will cause the dependency list to go stale.\\n\\nThe trade-off seems good as the unsupport cases are not the common case, the workaround is trivial (restart the engine).\\n\\n### Watch the files for changes (FileWatcher)\\n\\nI wanted to keep file watching logic out of the core engine. From an architectural perspective this should be as \\"pluggable\\" feature while incurring as little effect on the runtime in a release build as possible.\\n\\n-   The overhead of building the `DependencyList` during loading seems fine to always in the build\\n-   The notion of a `DirtyList` also seems fine in a release build as it is rather isolated\\n-   However, the file watching code should not be in the core code.\\n\\nThis was solved by adding an `Actor` to the `Engine`. This approach is quite simple and encapsulates the file watching code quite nicely. The FileWatcher itself only depends on a file list and `file -> id` mapping table: it doesn\'t really need to understand much more than doing that mapping.\\n\\n#### Pseudo-code\\n\\n```\\non init:\\n    for each file in the dependency list\\n        set up a file watcher\\n\\non every Nth frame update:\\n    check if the file watcher has reported any changes\\n    if no, return\\n\\n    for each modified file\\n        look up the asset ids dependent on that file\\n        update the engine\'s dirty_list with those asset ids\\n```\\n\\n#### Rust code\\n\\n<details>\\nThis is certainly not the \\"best\\" code, but was good enough to get things working. I\'m still learning Rust, so feedback on improving this code is very welcome.\\n\\n```rust\\nuse crate::engine;\\nuse log::info;\\nuse std::{\\n    collections::HashSet,\\n    sync::{Arc, Mutex},\\n};\\n\\nuse notify::{Config, PollWatcher, RecursiveMode, Watcher};\\n\\npub struct FileWatcher {\\n    watcher: PollWatcher,\\n    dirty_list: Arc<Mutex<HashSet<String>>>,\\n}\\n\\nimpl FileWatcher {\\n    pub fn new(file_list: Vec<String>) -> Self {\\n        let (tx, rx) = std::sync::mpsc::channel();\\n        // use the PollWatcher and disable automatic polling\\n        let mut watcher = PollWatcher::new(tx, Config::default().with_manual_polling()).unwrap();\\n\\n        // Sort simply for display / debugging purposes\\n        let mut file_list = file_list;\\n        file_list.sort();\\n\\n        for f in file_list {\\n            info!(\\"Watching: {:?}\\", f);\\n            watcher\\n                .watch(f.as_ref(), RecursiveMode::NonRecursive)\\n                .unwrap();\\n        }\\n\\n        // run event receiver on a different thread, we want this one for user input\\n        let dirty_list = Arc::new(Mutex::new(HashSet::new()));\\n        {\\n            let dirty_list = dirty_list.clone();\\n            std::thread::spawn(move || {\\n                for res in rx {\\n                    match res {\\n                        Ok(event) => {\\n                            let mut v = dirty_list.lock().unwrap();\\n                            for p in event.paths {\\n                                v.insert(p.to_str().unwrap().to_string());\\n                            }\\n                        }\\n                        Err(e) => println!(\\"watch error: {:?}\\", e),\\n                    }\\n                }\\n            });\\n        }\\n        Self {\\n            watcher,\\n            dirty_list,\\n        }\\n    }\\n}\\n\\nimpl engine::Actor for FileWatcher {\\n    fn update(&mut self, frame_state: &engine::FrameState) {\\n        if frame_state.frame % 60 != 37 {\\n            return;\\n        }\\n        self.watcher.poll().unwrap();\\n\\n        let mut v = self.dirty_list.lock().unwrap();\\n        if v.len() == 0 {\\n            return;\\n        }\\n\\n        let values = v.drain();\\n        for file in values {\\n            info!(\\"File changed: {:?}\\", file);\\n            let entries = frame_state.dependency_list.entries_for_file(&file);\\n            for e in entries {\\n                frame_state.dirty_list.borrow_mut().push(e.clone());\\n            }\\n        }\\n    }\\n}\\n```\\n\\n</details>\\n\\n### Communicate what\'s changed (DirtyList)\\n\\nThe Engine maintains a simple `DirtyList` to be notified about changes.\\n\\nI wanted to avoid complex event system, callbacks, object references or anything of that sort. So it simply has a list of asset ids that are currently considered \\"dirty.\\"\\n\\nThe `FileWatcher`, on it\'s own file events, simply adds assets ids to this list.\\n\\nOn each frame, the `Engine` checks if the dirty list is non-empty. If so, it provides the hot reloader with the list of asset ids to reload (and the original DependencyList to do the back-mapping to files it may need to reload). It clears the list after telling the hot reloader to do its work.\\n\\n### Reload the asset (HotReloader)\\n\\nThe HotReloader uses a brute-force implementation (this likely will need to be revisted in the future).\\n\\nIf _anything_ needs to be reloaded, the hot reloader loads the entire scene from disk again. This has the advantage of being simple: it\'s a \\"clean slate\\" that uses the exact same logic as engine startup.\\n\\nIt then loops over all active entities in the engine and checks if they are in the dirty list. If they are, it copies in the relevant data from the freshly loaded scene over the current data -- thus refreshing the asset."},{"id":"/2024/08/18/p2","metadata":{"permalink":"/blog/2024/08/18/p2","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-18-p2/index.md","source":"@site/blog/2024-08-18-p2/index.md","title":"Rust generator \\"scripts\\"","description":"Updated the code base to run Rust code to generate models. The below heightmap is a combination of sin functions and noise functions, generated in Rust code.","date":"2024-08-18T00:00:00.000Z","tags":[{"inline":true,"label":"scripting","permalink":"/blog/tags/scripting"},{"inline":true,"label":"Rust","permalink":"/blog/tags/rust"}],"readingTime":0.145,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["scripting","Rust"]},"unlisted":false,"prevItem":{"title":"Hot reloading architecture","permalink":"/blog/2024/08/18/p1"},"nextItem":{"title":"MagicaVoxel VOX loading","permalink":"/blog/2024/08/17/index"}},"content":"Updated the code base to run Rust code to generate models. The below heightmap is a combination of sin functions and noise functions, generated in Rust code.\\n\\n![alt text](image.png)"},{"id":"/2024/08/17/index","metadata":{"permalink":"/blog/2024/08/17/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-17/index.md","source":"@site/blog/2024-08-17/index.md","title":"MagicaVoxel VOX loading","description":"Added support for loading MagicaVoxel VOX models. This relies almost entirely on the work of others as the model below was created by Mike Judge and the VOX loading code comes from jgraef\'s vox-format crate. The only real addition to the Snowfall code was to add a YAML descriptor for VOX models and to write a quick translation from the vox-format format to the existing internal voxel format.","date":"2024-08-17T00:00:00.000Z","tags":[{"inline":true,"label":"magicavoxel","permalink":"/blog/tags/magicavoxel"},{"inline":true,"label":"wgsl","permalink":"/blog/tags/wgsl"}],"readingTime":2.835,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["magicavoxel","wgsl"]},"unlisted":false,"prevItem":{"title":"Rust generator \\"scripts\\"","permalink":"/blog/2024/08/18/p2"},"nextItem":{"title":"Incremental progress","permalink":"/blog/2024/08/16/index"}},"content":"Added support for loading [MagicaVoxel VOX](https://ephtracy.github.io/) models. This relies almost entirely on the work of others as the model below was created by [Mike Judge](https://github.com/mikelovesrobots/mmmm) and the VOX loading code comes from [jgraef\'s](https://github.com/jgraef) [vox-format](https://github.com/jgraef/vox-format) crate. The only real addition to the Snowfall code was to add a YAML descriptor for VOX models and to write a quick translation from the `vox-format` format to the existing internal voxel format.\\n\\n#### From the todo list...\\n\\n-   [x] Support loading MagicaVoxel VOX files\\n-   [x] Display attribution info as the models are loaded\\n-   [x] Add voxel colors rather than just the normal-based shader\\n\\n<div style={{marginBottom: -48 }}>\\n![alt text](image-1.png)\\n</div>\\n\\n:::note Credits\\n\\n-   The [vox-format](https://github.com/jgraef/vox-format) crate for the VOX loading\\n-   Mike Judge\'s [Mini Mike\'s Metro Minis](https://github.com/mikelovesrobots/mmmm) for the model in the screenshot\\n\\n:::\\n\\n#### World coordinate based voxel shading/darkening\\n\\nNote that the shader is randomly darkening each voxel a bit based on it\'s world coordinate to make for an (intentionally) less uniformly colored look to the final render.\\n\\nNote that the array look-ups need to be expanded out as `if-else` branches as WGSL rejects attempts to index using a non-const value (i.e. `return shade_x[xi] + shade_y[yi] + shade_z[zi];` does not compile).\\n\\n```rust\\nconst shade_x = array<f32, 7>(0.05, 0.18, 0.10, 0.96, 0.46, 0.75, 0.55);\\nconst shade_y = array<f32, 7>(0.52, 0.52, 0.34, 0.03, 0.38, 0.01, 0.66);\\nconst shade_z = array<f32, 7>(0.33, 0.60, 0.80, 0.30, 0.16, 0.85, 0.13);\\n\\n// Shade the color based on the world coordinate grid position\\n//\\n// This gives a subtle variation to each voxel based on world position\\n// so that there\'s less uniformity to everything.  Subjectively produces\\n// a better looking result.\\n//\\n// Returns a [0-1] value.\\n//\\nfn shade_world_coord(world_coord : vec3<f32>) -> f32 {\\n    var grid_wc = vec3<i32>(floor(world_coord));\\n    var ix = (1 * grid_wc.x + 13 * grid_wc.y + 31 * grid_wc.z) % 7;\\n    var iy = (1 * grid_wc.y + 17 * grid_wc.z + 43 * grid_wc.x) % 7;\\n    var iz = (1 * grid_wc.z + 37 * grid_wc.x + 3 * grid_wc.y) % 7;\\n\\n\\n    // The shade arrays are [0-1] in range, so shade is [0-3]\\n    var shade = 0.0;\\n\\n    if ix == 0 {\\n        shade += shade_x[0];\\n    } else if ix == 1 {\\n        shade += shade_x[1];\\n    } else if ix == 2 {\\n        shade += shade_x[2];\\n    } else if ix == 3 {\\n        shade += shade_x[3];\\n    } else if ix == 4 {\\n        shade += shade_x[4];\\n    } else if ix == 5 {\\n        shade += shade_x[5];\\n    } else if ix == 6 {\\n        shade += shade_x[6];\\n    }\\n\\n    if iy == 0 {\\n        shade += shade_y[0];\\n    } else if iy == 1 {\\n        shade += shade_y[1];\\n    } else if iy == 2 {\\n        shade += shade_y[2];\\n    } else if iy == 3 {\\n        shade += shade_y[3];\\n    } else if iy == 4 {\\n        shade += shade_y[4];\\n    } else if iy == 5 {\\n        shade += shade_y[5];\\n    } else if iy == 6 {\\n        shade += shade_y[6];\\n    }\\n\\n    if iz == 0 {\\n        shade += shade_z[0];\\n    } else if iz == 1 {\\n        shade += shade_z[1];\\n    } else if iz == 2 {\\n        shade += shade_z[2];\\n    } else if iz == 3 {\\n        shade += shade_z[3];\\n    } else if iz == 4 {\\n        shade += shade_z[4];\\n    } else if iz == 5 {\\n        shade += shade_z[5];\\n    } else if iz == 6 {\\n        shade += shade_z[6];\\n    }\\n\\n    return shade/3.0;\\n}\\n\\n```"},{"id":"/2024/08/16/index","metadata":{"permalink":"/blog/2024/08/16/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-16/index.md","source":"@site/blog/2024-08-16/index.md","title":"Incremental progress","description":"Not much visually different, but improved the code base a bit. Most notably having the engine automatically run model generation scripts (rather than manually running scripts to create static assets) and improved logging.","date":"2024-08-16T00:00:00.000Z","tags":[{"inline":true,"label":"generation_id","permalink":"/blog/tags/generation-id"}],"readingTime":0.92,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["generation_id"]},"unlisted":false,"prevItem":{"title":"MagicaVoxel VOX loading","permalink":"/blog/2024/08/17/index"},"nextItem":{"title":"Progress","permalink":"/blog/2024/08/15/index"}},"content":"Not much visually different, but improved the code base a bit. Most notably having the engine automatically run model generation scripts (rather than manually running scripts to create static assets) and improved logging.\\n\\n### Changes\\n\\n\u2795 Split model definition YAML from generator script JS<br/>\\n\u2795 Landscape generator takes grid size as an optional parameter<br/>\\n\u2795 Improved logging output<br/>\\n\u2795 Default camera now set based on scene bounds<br/>\\n\u2795 Added `id` and `generation` to models to detect cache staleness<br/>\\n\u2795 Added `BoundingBox`<br/>\\n\ud83d\uddc4\ufe0f Split files for better organization<br/>\\n\u2795 git status alias not provides links to diffs on GitHub so summary changelogs like this are easier to create<br/>\\n\\n### Potential next steps\\n\\n**\ud83d\udd2e Hot reloading of the module when the script or model file changes**\\n\\nThe above is a bit tricky as it creates a dependency between the loading code, an async file watcher, and the main render loop. I don\'t yet have a clear vision for how to connect those in a non-intrusive manner, but otherwise would like to add \\"hot reloading\\" as a core piece of functionality to make development easier and faster."},{"id":"/2024/08/15/index","metadata":{"permalink":"/blog/2024/08/15/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-15/index.md","source":"@site/blog/2024-08-15/index.md","title":"Progress","description":"Shading placeholder","date":"2024-08-15T00:00:00.000Z","tags":[{"inline":true,"label":"wgsl","permalink":"/blog/tags/wgsl"},{"inline":true,"label":"wgpu","permalink":"/blog/tags/wgpu"}],"readingTime":1.56,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["wgsl","wgpu"]},"unlisted":false,"prevItem":{"title":"Incremental progress","permalink":"/blog/2024/08/16/index"},"nextItem":{"title":"WGPU progress","permalink":"/blog/2024/08/12/index"}},"content":"#### Shading placeholder\\n\\nAdded shading based on world coordinate positions. This was mostly a test of adding new uniforms and vertex shader outputs to the shader program.\\n\\n![alt text](image.png)\\n\\n#### Voxels\\n\\nAdded a voxel model. Very inefficient at this point, but \\"correct.\\"\\n\\n![alt text](image-1.png)\\n\\n#### Bug! \ud83d\udc1b\\n\\nTried increasing the resolution and found bugs :)\\n\\n![alt text](image-2.png)\\n\\n**Guess: missing array data?**\\n\\nManually counting the input data matches the generated positions array and checking against the runtime data...\\n\\n-   `4416 voxels * 6 faces/voxel * 8 positions/face => 105984 positiions`\\n-   `4416 voxels * 6 faces/voxel * 6 indices/face => 158976 indices`\\n\\n...seems correct.\\n\\n**Guess: too many draw calls?**\\n\\nSeems impossible as this is a single mesh.\\n\\n**Investigation: is it always the same voxels that are missing?**\\n\\nFlipping the order of the voxels during generation changes the missing voxels. Not sure what to conclude from this yet.\\n\\n![alt text](image-3.png)\\n\\nDrawing just the Z+ face on the voxels seems to work correctly. The same seems to be true when rendering any one of the six faces.\\n\\n![alt text](image-4.png)\\n\\n...but if as soon as 3 faces are rendered together, voxels seem to be lost.\\n\\n**Guess: too many indicies**\\n\\nYup. The code is using `u16` which has a max representable value of `256*256 = 65,536`. There are `158,976` indices.\\n\\nChanging to a `u32` index buffer addresses the problem.\\n\\n![alt text](image-5.png)\\n\\n**Resolution**\\n\\nBumping the render code to always use `u32` seems fine for this stage of development. Using the larger buffer size affords more flexibility, which is a higher priority right now than optimization for memory or performance.\\n\\nVoxel chunking and optimizing away invisible faces need to be done regardless. After that is done, it should be easier to move back to a `u16` index buffer.\\n\\n#### A larger model\\n\\nWith the bug fixed, here\'s a sine + cosine generated voxel heightmap of `128x128x32` resolution.\\n\\n![alt text](image-6.png)"},{"id":"/2024/08/12/index","metadata":{"permalink":"/blog/2024/08/12/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-12/index.md","source":"@site/blog/2024-08-12/index.md","title":"WGPU progress","description":"Progress update: have some vertices making it from disk to the screen. That\'s a cube sitting behind of a \\"2D\\" pentagon (not necessarily obvious without lights or shading yet).","date":"2024-08-12T00:00:00.000Z","tags":[{"inline":true,"label":"wgpu","permalink":"/blog/tags/wgpu"}],"readingTime":0.575,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["wgpu"]},"unlisted":false,"prevItem":{"title":"Progress","permalink":"/blog/2024/08/15/index"},"nextItem":{"title":"Worth reading","permalink":"/blog/2024/08/11/index"}},"content":"Progress update: have some vertices making it from disk to the screen. That\'s a cube sitting behind of a \\"2D\\" pentagon (not necessarily obvious without lights or shading yet).\\n\\nThe general task I\'ve been working on is taking the \\"catch-all\\" `State` object from the [Learn Wgpu tutorial](https://sotrh.github.io/learn-wgpu/) and refactoring into a rendering architecture. This requires wrangling with lifetimes and data sharing, both in my learning how Rust works as well as how objects work in wgpu.\\n\\n![alt text](image-1.png)\\n\\nA bit more progress, getting basic semi-harcoded face shading working. Also changed the camera axes to a `Z+ => UP` system.\\n\\n![alt text](image.png)\\n\\nA bit more progress: depth buffering finally enabled and rendering multiple objects.\\n\\n![alt text](image-2.png)"},{"id":"/2024/08/11/index","metadata":{"permalink":"/blog/2024/08/11/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-11/index.md","source":"@site/blog/2024-08-11/index.md","title":"Worth reading","description":"-   Arc and Mutex in Rust - useful examples and explanation about thes Rust types","date":"2024-08-11T00:00:00.000Z","tags":[{"inline":true,"label":"worth-reading","permalink":"/blog/tags/worth-reading"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"wgpu","permalink":"/blog/tags/wgpu"}],"readingTime":0.125,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["worth-reading","rust","wgpu"]},"unlisted":false,"prevItem":{"title":"WGPU progress","permalink":"/blog/2024/08/12/index"},"nextItem":{"title":"Following the wgpu tutorial","permalink":"/blog/2024/08/10/index"}},"content":"-   [Arc and Mutex in Rust](https://itsallaboutthebit.com/arc-mutex/) - useful examples and explanation about thes Rust types\\n-   [Reddit thread about wgpu buffers](https://www.reddit.com/r/rust/comments/141ll5b/wgpu_questions_vertex_buffers/)\\n-   [WebGPU Buffer Uploads](https://toji.dev/webgpu-best-practices/buffer-uploads.html)"},{"id":"/2024/08/10/index","metadata":{"permalink":"/blog/2024/08/10/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-10/index.md","source":"@site/blog/2024-08-10/index.md","title":"Following the wgpu tutorial","description":"Ramping up on the custom rendering engine by going through the excellent Learn Wgpu tutorial. There\'s not much to say that\'s insightful here, but I find it\'s nice to create \\"early days\\" blog posts and images to highlight progress over time.","date":"2024-08-10T00:00:00.000Z","tags":[{"inline":true,"label":"wgpu","permalink":"/blog/tags/wgpu"}],"readingTime":1.205,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["wgpu"]},"unlisted":false,"prevItem":{"title":"Worth reading","permalink":"/blog/2024/08/11/index"}},"content":"Ramping up on the custom rendering engine by going through the excellent [Learn Wgpu tutorial](https://sotrh.github.io/learn-wgpu/). There\'s not much to say that\'s insightful here, but I find it\'s nice to create \\"early days\\" blog posts and images to highlight progress over time.\\n\\n![alt text](image-1.png)\\n\\n#### I read a comment along the lines of \\"wgpu has so much boilerplate\\"\\n\\nThough pedantic, I\'d argue wgpu has a lot of _configuration_. I tend to consider boilerplate code common text that _must be_ repeated to properly structure or specify another piece of _non-common_ configuration or otherwise unique code. (Note: my personal definition is _very_ different from [AWS\' definition](https://aws.amazon.com/what-is/boilerplate-code/) which portrays \\"boilerplate\\" as a positive). By \\"must be repeated\\", I\'m alluding to the kind of code that cannot be encapsulated easily into a reusable function, library, or other standard language primitive -- let\'s ignore macros certainly blur that line and just run with this hand-wavy definition!\\n\\nIn the context of creating _many different wgpu programs_, I can see how repeating the exact same configuration would constitue a good deal of \\"boilerplate code.\\" However, that commonality could be easily wrapped into a reusable library, which -- if we\'re willing to run with my definition of boilerplate code! -- means it is not boilerplate code as the code does not have the quality that it \\"must be\\" repeated.\\n\\nIn the context of a single program, wgpu strikes me simply as a very low-level library with detailed, highly structured configuration."}]}}')}}]);