"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2024/08/15/index","metadata":{"permalink":"/blog/2024/08/15/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-15/index.md","source":"@site/blog/2024-08-15/index.md","title":"Progress","description":"Shading placeholder","date":"2024-08-15T00:00:00.000Z","tags":[],"readingTime":1.56,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"nextItem":{"title":"WGPU progress","permalink":"/blog/2024/08/12/index"}},"content":"#### Shading placeholder\\n\\nAdded shading based on world coordinate positions. This was mostly a test of adding new uniforms and vertex shader outputs to the shader program.\\n\\n![alt text](image.png)\\n\\n#### Voxels\\n\\nAdded a voxel model. Very inefficient at this point, but \\"correct.\\"\\n\\n![alt text](image-1.png)\\n\\n#### Bug! \ud83d\udc1b\\n\\nTried increasing the resolution and found bugs :)\\n\\n![alt text](image-2.png)\\n\\n**Guess: missing array data?**\\n\\nManually counting the input data matches the generated positions array and checking against the runtime data...\\n\\n-   `4416 voxels * 6 faces/voxel * 8 positions/face => 105984 positiions`\\n-   `4416 voxels * 6 faces/voxel * 6 indices/face => 158976 indices`\\n\\n...seems correct.\\n\\n**Guess: too many draw calls?**\\n\\nSeems impossible as this is a single mesh.\\n\\n**Investigation: is it always the same voxels that are missing?**\\n\\nFlipping the order of the voxels during generation changes the missing voxels. Not sure what to conclude from this yet.\\n\\n![alt text](image-3.png)\\n\\nDrawing just the Z+ face on the voxels seems to work correctly. The same seems to be true when rendering any one of the six faces.\\n\\n![alt text](image-4.png)\\n\\n...but if as soon as 3 faces are rendered together, voxels seem to be lost.\\n\\n**Guess: too many indicies**\\n\\nYup. The code is using `u16` which has a max representable value of `256*256 = 65,536`. There are `158,976` indices.\\n\\nChanging to a `u32` index buffer addresses the problem.\\n\\n![alt text](image-5.png)\\n\\n**Resolution**\\n\\nBumping the render code to always use `u32` seems fine for this stage of development. Using the larger buffer size affords more flexibility, which is a higher priority right now than optimization for memory or performance.\\n\\nVoxel chunking and optimizing away invisible faces need to be done regardless. After that is done, it should be easier to move back to a `u16` index buffer.\\n\\n#### A larger model\\n\\nWith the bug fixed, here\'s a sine + cosine generated voxel heightmap of `128x128x32` resolution.\\n\\n![alt text](image-6.png)"},{"id":"/2024/08/12/index","metadata":{"permalink":"/blog/2024/08/12/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-12/index.md","source":"@site/blog/2024-08-12/index.md","title":"WGPU progress","description":"Progress update: have some vertices making it from disk to the screen. That\'s a cube sitting behind of a \\"2D\\" pentagon (not necessarily obvious without lights or shading yet).","date":"2024-08-12T00:00:00.000Z","tags":[],"readingTime":0.575,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Progress","permalink":"/blog/2024/08/15/index"},"nextItem":{"title":"Worth reading","permalink":"/blog/2024/08/11/index"}},"content":"Progress update: have some vertices making it from disk to the screen. That\'s a cube sitting behind of a \\"2D\\" pentagon (not necessarily obvious without lights or shading yet).\\n\\nThe general task I\'ve been working on is taking the \\"catch-all\\" `State` object from the [Learn Wgpu tutorial](https://sotrh.github.io/learn-wgpu/) and refactoring into a rendering architecture. This requires wrangling with lifetimes and data sharing, both in my learning how Rust works as well as how objects work in wgpu.\\n\\n![alt text](image-1.png)\\n\\n\\nA bit more progress, getting basic semi-harcoded face shading working.  Also changed the camera axes to a `Z+ => UP` system.\\n\\n![alt text](image.png)\\n\\n\\nA bit more progress: depth buffering finally enabled and rendering multiple objects.\\n\\n![alt text](image-2.png)"},{"id":"/2024/08/11/index","metadata":{"permalink":"/blog/2024/08/11/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-11/index.md","source":"@site/blog/2024-08-11/index.md","title":"Worth reading","description":"-   Arc and Mutex in Rust - useful examples and explanation about thes Rust types","date":"2024-08-11T00:00:00.000Z","tags":[],"readingTime":0.125,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"WGPU progress","permalink":"/blog/2024/08/12/index"},"nextItem":{"title":"Following the wgpu tutorial","permalink":"/blog/2024/08/10/index"}},"content":"-   [Arc and Mutex in Rust](https://itsallaboutthebit.com/arc-mutex/) - useful examples and explanation about thes Rust types\\n-   [Reddit thread about wgpu buffers](https://www.reddit.com/r/rust/comments/141ll5b/wgpu_questions_vertex_buffers/)\\n-   [WebGPU Buffer Uploads](https://toji.dev/webgpu-best-practices/buffer-uploads.html)"},{"id":"/2024/08/10/index","metadata":{"permalink":"/blog/2024/08/10/index","editUrl":"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/blog/2024-08-10/index.md","source":"@site/blog/2024-08-10/index.md","title":"Following the wgpu tutorial","description":"Ramping up on the custom rendering engine by going through the excellent Learn Wgpu tutorial.  There\'s not much to say that\'s insightful here, but I find it\'s nice to create \\"early days\\" blog posts and images to highlight progress over time.","date":"2024-08-10T00:00:00.000Z","tags":[],"readingTime":1.205,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Worth reading","permalink":"/blog/2024/08/11/index"}},"content":"Ramping up on the custom rendering engine by going through the excellent [Learn Wgpu tutorial](https://sotrh.github.io/learn-wgpu/).  There\'s not much to say that\'s insightful here, but I find it\'s nice to create \\"early days\\" blog posts and images to highlight progress over time.\\n\\n![alt text](image-1.png)\\n\\n####  I read a comment along the lines of \\"wgpu has so much boilerplate\\"\\n\\nThough pedantic, I\'d argue wgpu has a lot of _configuration_. I tend to consider boilerplate code common text that _must be_ repeated to properly structure or specify another piece of _non-common_ configuration or otherwise unique code. (Note: my personal definition is _very_ different from [AWS\' definition](https://aws.amazon.com/what-is/boilerplate-code/) which portrays \\"boilerplate\\" as a positive).  By \\"must be repeated\\", I\'m alluding to the kind of code that cannot be encapsulated easily into a reusable function, library, or other standard language primitive -- let\'s ignore macros certainly blur that line and just run with this hand-wavy definition!\\n\\nIn the context of creating _many different wgpu programs_, I can see how repeating the exact same configuration would constitue a good deal of \\"boilerplate code.\\" However, that commonality could be easily wrapped into a reusable library, which -- if we\'re willing to run with my definition of boilerplate code! -- means it is not boilerplate code as the code does not have the quality that it \\"must be\\" repeated.\\n\\nIn the context of a single program, wgpu strikes me simply as a very low-level library with detailed, highly structured configuration."}]}}')}}]);