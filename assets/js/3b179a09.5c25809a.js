"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[279],{2297:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>u});var o=t(4848),i=t(8453),a=(t(4252),t(1595));const s={},r="Action Queue",c={id:"snowfall/tutorial-wgpu-arch/actions",title:"Action Queue",description:'An Action Queue follows the "Gang of Four" Command design pattern and is introduced in order to:',source:"@site/docs/snowfall/800-tutorial-wgpu-arch/808-actions.mdx",sourceDirName:"snowfall/800-tutorial-wgpu-arch",slug:"/snowfall/tutorial-wgpu-arch/actions",permalink:"/docs/snowfall/tutorial-wgpu-arch/actions",draft:!1,unlisted:!1,editUrl:"https://github.com/raiment-studios/monorepo/tree/main/projects/raiment-studios/web2/docs/snowfall/800-tutorial-wgpu-arch/808-actions.mdx",tags:[],version:"current",sidebarPosition:808,frontMatter:{},sidebar:"snowfallSidebar",previous:{title:"Introduction",permalink:"/docs/snowfall/tutorial-wgpu-arch/intro"},next:{title:"References",permalink:"/docs/snowfall/references"}},l={},u=[{value:"Implementation",id:"implementation",level:4},{value:"Enumerating all actions",id:"enumerating-all-actions",level:4},{value:"Queuing up the actions",id:"queuing-up-the-actions",level:4},{value:"Mapping input to actions",id:"mapping-input-to-actions",level:4},{value:"Executing Actions",id:"executing-actions",level:4}];function d(e){const n={code:"code",em:"em",h1:"h1",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"action-queue",children:"Action Queue"})}),"\n",(0,o.jsxs)(n.p,{children:['An Action Queue follows the "Gang of Four" ',(0,o.jsx)(n.strong,{children:"Command design pattern"})," and is introduced in order to:"]}),"\n",(0,o.jsxs)(a.y,{children:[(0,o.jsx)(o.Fragment,{children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Decouple input from actions"}),"\n",(0,o.jsxs)(n.li,{children:["Ease implemenation of:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Custom key bindings"}),"\n",(0,o.jsx)(n.li,{children:"New controller methods"}),"\n",(0,o.jsx)(n.li,{children:"Automated / simulated user input"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Process engine changes in a well-defined, deterministic order in the pipeline"}),"\n"]})}),(0,o.jsx)(o.Fragment,{children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Multiple places to update for every new action"}),"\n"]})})]}),"\n",(0,o.jsx)(n.h4,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(n.p,{children:"To implement this we introduce the following distinct pieces of code:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"An enum for all the possible actions"}),"\n",(0,o.jsx)(n.li,{children:"An ActionQueue for storing actions generated from user input or other sources"}),"\n",(0,o.jsx)(n.li,{children:'A "key mapper" for translating user input into actions'}),"\n",(0,o.jsx)(n.li,{children:"An Action processor for running actions in the frame loop"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"enumerating-all-actions",children:"Enumerating all actions"}),"\n",(0,o.jsx)(n.p,{children:"In a smaller engine, having a well-defined set of actions can help keep the codebase understandable as this makes the API of the engine very clear. In a more complex engine, it may be useful to introduce dynamic actions so plugins may add new action types that the core engine is not aware of. For this tutorial, we'll stick to a fixed set of actions, as exemplified below:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone)]\npub enum Action {\n    MoveForward(f32),\n    MoveBackward(f32),\n    RotateRight(f32),\n    RotateLeft(f32),\n    MoveUp(f32),\n    MoveDown(f32),\n    MoveLeft(f32),\n    MoveRight(f32),\n    // etc.\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"queuing-up-the-actions",children:"Queuing up the actions"}),"\n",(0,o.jsxs)(n.p,{children:["In the context of a rendering engine, a key constraint is the actions will be processed at a well-known time during the frame rendering. In the simplest case, we could use a simple ",(0,o.jsx)(n.code,{children:"Vec"})," that enqueues the actions and processes them all in order at the start of the frame, leaving the Vec empty after processing."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"pub struct ActionQueue {\n    queue: Vec<Action>,\n    frame_queue: HashMap<String, Action>,\n    persist_queue: HashMap<String, Action>,\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, in practice, it is often useful to have two additional variations of actions:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"1. Actions types that can be enqueued at most once per frame"}),'. For example, if a "jump" action is triggered by the keyboard, we don\'t necessarily want it to be possible to ',(0,o.jsx)(n.em,{children:"also"}),' create a second "jump" action via a controller or joystick. One solution to this is to make each such action idempotent, but this can be error-prone as it needs to be implemented for each such action. Instead, per the code below, we introduce the idea of a ',(0,o.jsx)(n.code,{children:"frame_queue"})," that only allows one action of a given type per frame."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"2. Actions that persist until explicitly removed"}),'. Another special case is a user input that triggers the start / end of an action that is to be run every frame. For example, an input to "move forward" that is ',(0,o.jsx)(n.em,{children:"continually"})," moves the player character forward until an explicit input to stop would add an action and want it to be processed every frame until it is removed. This is the purpose of ",(0,o.jsx)(n.code,{children:"persist_queue"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'impl Action {\n    // Provide a unique id to each action type so that we can match\n    // against types, not just full values.\n    pub fn to_type(&self) -> &\'static str {\n        use Action::*;\n        match self {\n            MoveForward(_) => "MoveForward",\n            MoveBackward(_) => "MoveBackward",\n            RotateRight(_) => "RotateRight",\n            RotateLeft(_) => "RotateLeft",\n            MoveUp(_) => "MoveUp",\n            MoveDown(_) => "MoveDown",\n            MoveLeft(_) => "MoveLeft",\n            MoveRight(_) => "MoveRight",\n        }\n    }\n}\n\nimpl ActionQueue {\n    pub fn new() -> ActionQueue {\n        ActionQueue {\n            queue: Vec::new(),\n            frame_queue: HashMap::new(),\n            persist_queue: HashMap::new(),\n        }\n    }\n\n    pub fn enqueue(&mut self, action: Action) {\n        self.queue.push(action);\n    }\n\n    // Ensures at most one of the action type is in the queue for a\n    // given frame. Subsequent calls replace prior actions of the same type.\n    pub fn enqueue_frame(&mut self, action: Action) {\n        self.frame_queue\n            .insert(action.to_type().to_string(), action);\n    }\n\n    pub fn toggle_persist(&mut self, action: Action, enable: bool) {\n        let key = action.to_type();\n        if enable {\n            self.persist_queue.insert(key.to_string(), action);\n        } else {\n            self.persist_queue.remove(key);\n        }\n    }\n\n    // Drains all one-time actions and frame actions, clones all\n    // persistent actions.\n    pub fn drain_actions_for_frame(&mut self) -> Vec<Action> {\n        let mut actions = Vec::new();\n        actions.extend(self.queue.drain(..));\n        actions.extend(self.frame_queue.drain().map(|(_, v)| v));\n        actions.extend(self.persist_queue.values().cloned());\n        actions\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"mapping-input-to-actions",children:"Mapping input to actions"}),"\n",(0,o.jsx)(n.p,{children:"The next component is the mapper that takes various input and creates the Actions. This is fairly straightforward and is simply a mapping from whatever input system is being used to the creation of an Action object."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use winit::keyboard::KeyCode;\n\nuse crate::action_queue::ActionQueue;\n\npub fn map_to_action(q: &mut ActionQueue, keycode: &KeyCode, is_pressed: bool) -> bool {\n    use crate::action_queue::Action::*;\n\n    const STEP: f32 = 0.1;\n\n    match keycode {\n        KeyCode::KeyW | KeyCode::ArrowUp => {\n            q.toggle_persist(MoveForward(STEP), is_pressed);\n        }\n        KeyCode::KeyQ | KeyCode::ArrowLeft => {\n            q.toggle_persist(RotateLeft(STEP), is_pressed);\n        }\n        KeyCode::KeyS | KeyCode::ArrowDown => {\n            q.toggle_persist(MoveBackward(STEP), is_pressed);\n        }\n        KeyCode::KeyE | KeyCode::ArrowRight => {\n            q.toggle_persist(RotateRight(STEP), is_pressed);\n        }\n        KeyCode::KeyR => {\n            q.toggle_persist(MoveUp(STEP), is_pressed);\n        }\n        KeyCode::KeyF => {\n            q.toggle_persist(MoveDown(STEP), is_pressed);\n        }\n        KeyCode::KeyA => {\n            q.toggle_persist(MoveLeft(STEP), is_pressed);\n        }\n        KeyCode::KeyD => {\n            q.toggle_persist(MoveRight(STEP), is_pressed);\n        }\n        _ => return false,\n    };\n    true\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"executing-actions",children:"Executing Actions"}),"\n",(0,o.jsx)(n.p,{children:"Lastly, at a well-defined point in the frame loop update, we need to process the actions that have been enqueued thus far."}),"\n",(0,o.jsx)(n.p,{children:'In a more complex engine, it would be likely be beneficial to allow action handlers to be "pluggable" both for code organization purposes (e.g. isolating all camera related action handlers to one file) as well as for the introduction of extensibility.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"    fn update_actions(&mut self) {\n        let actions = self.action_queue.drain_actions_for_frame();\n\n        use cgmath::InnerSpace;\n        let cam = &mut self.scene.camera;\n        let forward = cam.target - cam.position;\n        let forward_norm = forward.normalize();\n        let forward_mag = forward.magnitude();\n        let right = forward_norm.cross(cam.up);\n        let camera_close_to_target = forward_mag < 2.0;\n\n        use action_queue::Action::*;\n        for action in actions {\n            match action {\n                MoveForward(step) => {\n                    if camera_close_to_target {\n                        continue;\n                    }\n                    cam.target += forward_norm * step;\n                    cam.position += forward_norm * step;\n                }\n                MoveBackward(step) => {\n                    cam.target -= forward_norm * step;\n                    cam.position -= forward_norm * step;\n                }\n                RotateLeft(step) => {\n                    cam.position = cam.target - (forward + right * step).normalize() * forward_mag;\n                }\n                RotateRight(step) => {\n                    cam.position = cam.target - (forward - right * step).normalize() * forward_mag;\n                }\n                MoveUp(step) => {\n                    cam.target += cam.up * step;\n                    cam.position += cam.up * step;\n                }\n                MoveDown(step) => {\n                    cam.target -= cam.up * step;\n                    cam.position -= cam.up * step;\n                }\n                MoveLeft(step) => {\n                    cam.target -= right * step;\n                    cam.position -= right * step;\n                }\n                MoveRight(step) => {\n                    cam.target += right * step;\n                    cam.position += right * step;\n                }\n            }\n        }\n    }\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1595:(e,n,t)=>{t.d(n,{y:()=>i});t(6540);var o=t(4848);function i(e){let{children:n}=e;return(0,o.jsxs)("div",{style:{display:"flex",flexDirection:"row"},children:[(0,o.jsxs)("div",{className:"checklist-pros",children:[(0,o.jsx)("strong",{children:"Pros"}),n[0]]}),(0,o.jsxs)("div",{className:"checklist-cons",children:[(0,o.jsx)("strong",{children:"Cons"}),n[1]]})]})}},4252:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var o=t(5195);const i={tableOfContentsInline:"tableOfContentsInline_prmo"};var a=t(4848);function s(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:s}=e;return(0,a.jsx)("div",{className:i.tableOfContentsInline,children:(0,a.jsx)(o.A,{toc:n,minHeadingLevel:t,maxHeadingLevel:s,className:"table-of-contents",linkClassName:null})})}},5195:(e,n,t)=>{t.d(n,{A:()=>f});var o=t(6540),i=t(6342);function a(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),t=Array(7).fill(-1);n.forEach(((e,n)=>{const o=t.slice(2,e.level);e.parentIndex=Math.max(...o),t[e.level]=n}));const o=[];return n.forEach((e=>{const{parentIndex:t,...i}=e;t>=0?n[t].children.push(i):o.push(i)})),o}function s(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:o}=e;return n.flatMap((e=>{const n=s({toc:e.children,minHeadingLevel:t,maxHeadingLevel:o});return function(e){return e.level>=t&&e.level<=o}(e)?[{...e,children:n}]:n}))}function r(e){const n=e.getBoundingClientRect();return n.top===n.bottom?r(e.parentNode):n}function c(e,n){let{anchorTopOffset:t}=n;const o=e.find((e=>r(e).top>=t));if(o){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(r(o))?o:e[e.indexOf(o)-1]??null}return e[e.length-1]??null}function l(){const e=(0,o.useRef)(0),{navbar:{hideOnScroll:n}}=(0,i.p)();return(0,o.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function u(e){const n=(0,o.useRef)(void 0),t=l();(0,o.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:o,linkActiveClassName:i,minHeadingLevel:a,maxHeadingLevel:s}=e;function r(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(o),r=function(e){let{minHeadingLevel:n,maxHeadingLevel:t}=e;const o=[];for(let i=n;i<=t;i+=1)o.push(`h${i}.anchor`);return Array.from(document.querySelectorAll(o.join()))}({minHeadingLevel:a,maxHeadingLevel:s}),l=c(r,{anchorTopOffset:t.current}),u=e.find((e=>l&&l.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,t){t?(n.current&&n.current!==e&&n.current.classList.remove(i),e.classList.add(i),n.current=e):e.classList.remove(i)}(e,e===u)}))}return document.addEventListener("scroll",r),document.addEventListener("resize",r),r(),()=>{document.removeEventListener("scroll",r),document.removeEventListener("resize",r)}}),[e,t])}var d=t(8774),p=t(4848);function m(e){let{toc:n,className:t,linkClassName:o,isChild:i}=e;return n.length?(0,p.jsx)("ul",{className:i?void 0:t,children:n.map((e=>(0,p.jsxs)("li",{children:[(0,p.jsx)(d.A,{to:`#${e.id}`,className:o??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,p.jsx)(m,{isChild:!0,toc:e.children,className:t,linkClassName:o})]},e.id)))}):null}const h=o.memo(m);function f(e){let{toc:n,className:t="table-of-contents table-of-contents__left-border",linkClassName:r="table-of-contents__link",linkActiveClassName:c,minHeadingLevel:l,maxHeadingLevel:d,...m}=e;const f=(0,i.p)(),g=l??f.tableOfContents.minHeadingLevel,v=d??f.tableOfContents.maxHeadingLevel,x=function(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:i}=e;return(0,o.useMemo)((()=>s({toc:a(n),minHeadingLevel:t,maxHeadingLevel:i})),[n,t,i])}({toc:n,minHeadingLevel:g,maxHeadingLevel:v});return u((0,o.useMemo)((()=>{if(r&&c)return{linkClassName:r,linkActiveClassName:c,minHeadingLevel:g,maxHeadingLevel:v}}),[r,c,g,v])),(0,p.jsx)(h,{toc:x,className:t,linkClassName:r,...m})}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(6540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);